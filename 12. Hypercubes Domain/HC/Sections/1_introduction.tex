Computer Games Software is a fast growing industry, with more than 200 million units sold every year, and annual revenue of more than 10 billion dollars. According to the Entertainment Software Association (ESA), more than 25\% of the software played concerns sport, action, and strategy games, where physics simulations are the core of the product, and compile-time verification of behavioural properties is particularly challenging for developers. 

The difficulty arises because, usually, these programs feature (i) a \statement{while} loop which goes on endlessly, (ii) a complex state made up by multiple real-valued variables, and (iii) strong dependencies among variables. 
Most of the times, a simulation consists in the initialization of the state (i.e., the variables which compose the simulated world) followed by an infinite \statement{while} loop which computes the numerical integration over time (i.e., the inductive step of the simulation). Such loop is executed until the game is stopped.
In addition, the variables of a physics simulation are real-valued, because they represent continuous values that map directly to physical aspects of the real world, like positions, velocities (speed plus direction), and accelerations. 
Finally, the variables of a simulation are strongly inter-related, because the simulation often makes decisions based on the values of particular variables. For example, the velocity of an object changes abruptly when there is a collision, which depends on the object position. Similarly, the position changes accordingly to the velocity, which in turn depends on the acceleration which may derive from the position (for a gravitational field) or from other parameters. 

Interesting properties on physical programs are, for example, the insurance that a rocket reaches a stable orbit, or that a bouncing ball arrives at a certain destination. To prove such properties statically, we need to precisely track relationships between variables. However, traditional approaches to static analysis are not best suited to deal with these kind of properties. On the one hand, non-relational domains 
%guarantee efficient analyses, but they 
are usually too approximate. On the other hand, the computational cost of sophisticated relational domains like Polyhedra \cite{CH78} or Parallelotopes \cite{AS12} is too high, and their practical use in this context becomes unfeasible.   

In this paper, we introduce Parametric Hypercubes, a novel disjunctive non-relational abstract domain. Its main features are: (i) it combines the low computational cost of operations on (selected) multidimensional intervals with the accuracy provided by lifting to a power-set domain, (ii) the compact representation of its elements allows to limit the space complexity of the analysis, and (iii) the parametric nature of the domain provides a way to tune the trade-off between accuracy and efficiency of the analysis by just setting the widths of the hypercubes sides. The domain can be seen as the combination of a suite of well-known techniques for numerical abstract domain design, like disjunctive powerset, and conditional partitioning. The most interesting points of our work are: (i) the approach: the design of the domain has as starting point the features of the application domains, (ii) the self-adaptive parameterization: a recursive algorithm is applied to refine the initial set of parameters in order to improve the accuracy of the analysis without sacrificing the performance, and (iii) the novel notion of \textquotedblleft offset\textquotedblright\ that allows to narrow the lack of precision due to the fixed width of intervals.
The analysis has been implemented, and it shows promising results in terms both of efficiency and precision when applied to a representative case study of Computer Games Software. 
%Also, we expect that our technique is generic enough to be successfully applied to other kinds of programs: an example is presented in Section \ref{sec:otherapplications}.

The rest of the paper is structured as follows. Section \ref{sec:syntax} presents the language syntax supported by our analysis and Section \ref{sec:case_study} introduces the case study which we use to experiment with our approach. Sections \ref{sec:hyper_cubes_domain} and \ref{sec:semantics} formally define the abstract domain and semantics, respectively. %Section \ref{sec:tuning} shows how to improve the performance and precision of the analysis. 
Section \ref{sec:experimental} contains the experimental results of our analysis applied to the case study of Section \ref{sec:case_study}. Section \ref{sec:related} presents the related work and Section \ref{sec:conclusions} concludes.

