Domain-Specific Languages (DSL's) are becoming more and more relevant in software engineering thanks to their ability to provide abstractions at language level to target specific problem domains \cite{van2000domain, voelter2013dsl}. Notable examples of the use of DSL's are (\textit{i}) game development (UnrealScript, JASS, Status-quo, NWScript), (\textit{ii}) Database programming and design (SQL, LINQ), and (\textit{iii}) numerical analysis and engineering (MATLAB, Octave). A notable amount of work on DSL's is made in the field of game development, as games are complex and they require, for performance reasons, to implement abstractions that exhibit the behaviours of threads. Indeed the overhead of threads is too big to be used in games to update every single entity in it, as their number can approach to the order of thousands (just think about a shooter game where the player can shoot with an automatic rifle at a rate of 30 rounds per second).

Two main alternatives have been proposed for the development of DSL's: the (\textit{i}) \textit{Embedding} technique, and (\textit{ii}) the \textit{Interpretation/Compilation} technique \cite{mernik2005and}. 

The former approach extends an existing programming language with the additional abstractions of the DSL. This is the case, for instance, of NWScript, a scripting language for the Neverwinter Nights game extending the C language, and LINQ, which offers SQL-like abstractions extending C\#. This technique has the advantage that the infrastructure of the host language can be widely re-used, thus reducing the development effort. Moreover, people who are expert on the host language can become proficient with the DSL extension in a short time. The disadvantages are that the syntax is likely to be far from that of the DSL formal syntax, since General-Purpose Languages generally do not offer syntax extensions, and Domain-specific optimizations are difficult to achieve \cite{kamin1998research, sloane2002post}.

The latter approach requires to develop an interpreter or compiler for the language. This is the case, for instance, of UnrealScript, JASS, and SQL. This approach has the advantages of providing a syntax close to the formal definition of the Domain-specific language, good error reporting, and domain-specific optimization through code analysis. However, designing and implementing a compiler for a DSL is a hard and time-consuming task, since a compiler is a complex piece of software made of different modules that perform several translation steps \cite{aho1986compilers}. For this reason this option is not always considered feasible.

The translation steps performed by a compiler are not part of the creative aspect of designing the language \cite{book1970cwic, czarnecki2000generative}. Therefore, they can be automated. The most common automated part is the Lexing/Parsing phase with Parser generators such as \texttt{Yacc}. A further effort in fully automating the development of a compiler has been done by employing \textit{Meta-compilers}, that are computer programs that take as input the definition of a language (usually defined in a \textit{meta-language}), a program written in that language and output executable code for the program. Meta-compilers usually automate not only the parsing phase, but also the type checking and the semantics implementation.
 
In this paper we present \textit{Metacasanova}, a meta-compiler whose meta-language is based on operational semantics \cite{plotkin1981, kahn1987natural}, which was a project whose goal was easing the development and extension of the DSL for games \textit{Casanova} \cite{abbadi2015casanova, abbadithesis2017, DIGIACOMO201725}, and a possible extension that aims to improve the performance of languages built in Metacasanova. In Section \ref{sec:problem} we further discuss how developing a compiler leads to repetitive steps that could be automated and we formulate the problem statement of this paper; in Section \ref{sec:semantics} we explain how the meta-language of Metacasanova is defined and what its semantics are; in Section \ref{sec:code_generation} we explain how the meta-compilation process is implemented in Metacasanova and how the target code is generated; in Section \ref{sec:functors} we propose a further language abstraction for Metacasanova in order to improve the performance of the generated code; in Section \ref{sec:evaluation} we evaluate the performance of the code generated by Metacasanova after re-implementing Casanova \cite{abbadi2015casanova}, a DSL for game development, and a subset of the C language. We also evaluate the performance gain given by the presented code optimization.

