\balance
In this work we presented the architecture of a Metacompiler called Metacasanova, whose meta-language is based on the operational semantics. In Section \ref{sec:problem} we discussed how it is possible to capture repetitive patterns in designing a compiler for DSL through a meta-compiler. We presented the meta-compiler Metacasanova and its meta-language. Metacasanova has been evaluated by re-implementing the DSL for games Casanova, and by implementing a subset of the C language, called C -{}-. Our results show that implementing the language semantics in Metacasanova is up to 8 times shorter than with a hard-coded compiler. The additional abstraction layer of the meta-compiler leads to a performance decay that, in the case of C-{}-, makes the language 50 times slower than Python, and in the case of Casanova on the same order but still 3 times slower. We identified the problem in the fact that the meta-language is unaware of the type system and memory model of the implemented language, thus all type checks and field lookups must be done dynamically at runtime adding the overhead of a dynamic lookup table. We have proposed a language extension based on \textit{Modules} and \textit{Functors} that allows the meta-language to embed the type system of the implemented language in the meta-type system, and to inline the lookups directly into the generated code. This optimization leads to a performance improvement factor of 11, which peaks to 30 in presence of many updates and data structures with many fields.