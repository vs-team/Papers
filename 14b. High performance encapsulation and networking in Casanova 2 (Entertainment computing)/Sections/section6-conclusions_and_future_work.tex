Game developers often have to choose between maintainability of their code and speed of execution, a choice that more often than not favors speed over maintainability. By using encapsulation, game code may be written in a maintainable way, but compilation of encapsulated code in general-purpose languages often leads to slower games. We proposed a solution to the loss of performance in encapsulated programs using automated optimization at compile time. 
We presented an implementation of this solution in the Casanova 2 language. We showed that our approach transforms encapsulated code, through extensive automated optimization, into a high-performance executable that easily rivals the speed of a C\# implementation. Moreover, we showed that Casanova 2 code needs about half the lines of code as the C\# implementation, with even more dramatic results if we consider well-known complex and verbose network code: good primitives for networking preserve encapsulation because they do not require polluting the identity of an entity with network specific information that it is not related to the game logic of the entity itself. Of course networking does impact the logic of the entity, but this should be reflected by minimal code adjustments. Our research, which is still in its initial stage, requires more (and more complex) samples and further investigation. Still, preliminary experiments suggest that our approach allows game developers to write clear, readable code, which is both high-performance and maintainable. 

In the near future, we will add a dynamic analysis of the game to automatically identify entities that exhibit temporal locality. Such an analysis must be done while playing the game to keep track of the amount of time that each rule stays inactive, and periodically the game must be recompiled to generate or remove the optimization code for an entity based on the temporal information generated by the analyser. 

Furthermore, we are actively developing a meta-compiler that generates predictable, high-performance code that makes very little to no use of dynamic constructs. A meta-compiler is a software that takes as input the definition of a programming language and a program written in that language and outputs executable code. This meta-compiler features a programmable, higher-kinded type system that feeds an aggressive code inliner. Our meta-compiler is designed to be agnostic with respect to the architecture of one's library for generating code: it could be used for Aspect-Oriented Programming, the inlining of monad transformers, query optimizations, and even other forms of static code analysis such as abstract interpretation or model checking. Such work is unfortunately very complex and as such is not yet in a state to be used in practice with the results of the current paper. We plan on rebuilding the existing Casanova compiler, and all of its optimizations, within the meta-compiler itself. A preliminary result can be found in \cite{meta_casanova}.


%\paragraph*{Future work}

%As seen in Algorithm \ref{alg:icds_construction} of Section \ref{sec:details}, in the current implementation only the first IC of a rule is considered for the optimization process. A further improvement to the optimizer is to use multiple ICs for the same rule. This requires a refinement of the mechanism of dictionaries to keep track at what IC the rule was halted.

%Furthermore, in the near future we will add a dynamic analysis of the game to automatically identify entities that exhibit temporal locality, to avoid developers having to indicate those entities by hand. Such an analysis must be done while playing the game to keep track of the amount of time that each rule stays inactive, and periodically the game must be recompiled to generate or remove the optimization code for an entity based on the temporal information generated by the analyzer. 