Game developers often have to choose between maintainability of their code and speed of execution, a choice which more often than not favors speed over maintainability. By using encapsulation, game code may be written in a maintainable way, but compilation of encapsulated code in general-purpose languages often leads to slower games. We proposed a solution to the loss of performance in encapsulated programs using automated optimization at compile-time. 
We presented an implementation of this solution in the Casanova 2 language. We showed that our approach transforms encapsulated code, through extensive automated optimization, into a high-performance executable, that easily rivals the speed of a C\# implementation. Moreover, we showed that Casanova 2 code needs about half the lines of code as the C\# implementation. We therefore conclude that our approach allows game developers to write high-performance code without losing maintainability.


%\paragraph*{Future work}

%As seen in Algorithm \ref{alg:icds_construction} of Section \ref{sec:details}, in the current implementation only the first IC of a rule is considered for the optimization process. A further improvement to the optimizer is to use multiple ICs for the same rule. This requires a refinement of the mechanism of dictionaries to keep track at what IC the rule was halted.

%Furthermore, in the near future we will add a dynamic analysis of the game to automatically identify entities that exhibit temporal locality, to avoid developers having to indicate those entities by hand. Such an analysis must be done while playing the game to keep track of the amount of time that each rule stays inactive, and periodically the game must be recompiled to generate or remove the optimization code for an entity based on the temporal information generated by the analyzer. 