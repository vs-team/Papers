In Section \ref{sec:encapsulation} we addressed the problem of the trade off between software engineering compliant implementations, such as the encapsulation, and performance. In this section we introduce the idea behind a map between encapsulated programs and a semantically equivalent and efficient implementation.

\subsection{Optimization overview}

In the example we saw that the main drawback of encapsulation is that each planet has to check all the fleets to see if they are close enough and to move them in the list of attacking fleets. An optimization can be achieved by maintaining an index \texttt{FleetIndex} in \texttt{Planet} containing a list of \texttt{Fleets} which satisfy the predicate in the query (being owned by a different player and close enough to the planet). When an enemy \texttt{Fleet} is close enough to a \texttt{Planet}, it is moved inside \texttt{FleetIndex} by the \texttt{Route} which stores a list of travelling fleets. When \texttt{FleetIndex}  changes, it notifies it to \texttt{Planet}, so that it can update \texttt{AttackingFleets}.

We can generalize this situation saying that encapsulation suffers the loss of performance whenever an object $B$ needs to update one of its fields depending on a property of another object $A$ or one of its fields. The object $B$ stores an index $I_{A}$ which is used to keep track of the objects satisfying the predicate. The object $A$ has a reference to $B$ and it is tasked to update the index $I_{A}$ of $B$. $B$ checks $I_{A}$ every time it needs to interact with the elements of $A$ satisfying the predicate.

\subsection{Language level integration}

This generalization breaks encapsulation, since the entity $A$ is writing an index which is stored in $B$. This process can be integrated at compiler level as code transformation, since the index creation and management always follows the same pattern, and thus the compiler itself can create and update the required data structures. Unfortunately general purpose programming languages do not impose a strict discipline on writing variables and thus we claim they are not suitable for our purpose. We chose Casanova 2, which is a game development oriented language, where variable writing is disciplined and possible only through specific statements.

The compiler will apply transformations to the code that preserve the program semantics and optimize the encapsulated implementation by creating and maintaining the required indices. In this way the code written by the programmer will benefit of the clearness and maintainability of an encapsulated program without neither suffering the loss of performance nor requiring to break encapsulation to manage the optimization data structures.

In Section \ref{sec:implementation} we present the compiler architecture and the transformation rules.