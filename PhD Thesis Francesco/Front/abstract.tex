\chapter*{Abstract}
\thispagestyle{empty}
Programming languages are a fundamental aspect of computer science, as they provide abstractions that allow to express the logic of a program independently of the underlying hardware architecture. In particular scenarios, it might be convenient to employ Domain-Specific Languages, which are capable of providing an even higher level of abstraction to solve problems limited to specific domains, for example database programming, text editing, 3D graphics, and game development. The use of a domain-specific language thought ad-hoc for the development of particular classes of software can drastically increase the development speed and the maintainability of the code, with respect to their counterpart written in a general-purpose programming language. This, however, comes at a cost: as all programming languages, domain-specific languages require a compiler that translates their programs in code that can be actually executed by the hardware. Implementing a compiler is a long and time-consuming task to the point that the advantages of a domain-specific languages can be overshadowed by the burden of developing its compiler. In order to ease the process of developing compilers, a special class of compilers called meta-compilers have been created. Meta-compilers have the advantage of requiring only the language definition in order to generate executable code for one of its programs, thus relieving the programmer from writing a hard-coded compiler for a programming language. Meta-compilers are generally used, for performance reasons, only for rapid prototyping of a programming language. In this work we present a meta-compiler called Metacasanova whose aim is both to ease the development cost of a compiler and at the same time to generate efficient code. In the first part of this thesis we begin by analysing the recurring patterns of implementing a compiler for a programming language that we use to define a series of requirements for Metacasanova. We then proceed to explain the architecture of the meta-compiler and we an example of its usage by implementing a small imperative language, called C-{}-, and by re-implementing the domain-specific language for games \textit{Casanova}. Moreover we present an optimization based on functors to optimize the performance of the code generated by Metacasanova, that we later use to improve the first implementation of Casanova and extend it with additional language semantics to define multiplayer online games.