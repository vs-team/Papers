This chapter provides an answer to the problem statement and research questions presented in Section \ref{sec:ch1_problem_statement}. The goal of the first research question is measuring the benefits of using a Metacompiler in terms of development speed when used to implement a domain-specific language for game development with respect to the implementation measured in code length. The goal of the second research question is aimed to determine the trade-off between a manual implementation of the language and an implementation with Metacasanova. The goal of the third research question is to identify reasons for this trade-off and propose an optimization to reduce it. The last part of this chapter answers the problem statement, provides an overview of future work and adds final remarks for this thesis.

\section{Answer to research questions}
\label{sec:ch_conclusion_answer_research_questions}
The three research questions stated in Section \ref{sec:ch1_problem_statement} are now answered  in Sections \ref{subsec:ch_conclusion_rq1}, \ref{subsec:ch_conclusion_rq2}, and \ref{subsec:ch_conclusion_rq3} respectively.

\subsection{Ease of development}
\label{subsec:ch_conclusion_rq1}

The first research question reads:\\\\
\researchQuestion{\rqContentOne}\\\\

The answer to this research question is derived from the results shown in Chapter \ref{ch:languages}. In this chapter we re-implemented the language semantics of two languages: a toy imperative language called C-{}- and the domain-specific language for game development Casanova. In Section \ref{sec:ch_mcnv_languages_evaluation} we showed how the use of Metacasanova reduces the effort in term of code writing for the compiler of Casanova as the code required for the definition of the language semantics is roughly 5 times shorter in Metacasanova than the hard-coded version of the compiler written in F\#. We obtained even better results with the implementation of the semantics of C-{}- that is roughly 10 times shorter than its hard-coded counterpart. This improvement is due to the fact that, in Metacasanova, it is possible to express the semantics of the language by mimicking almost directly the definition of Casanova written in natural semantics. Thus, in addition to the benefit in term of code length necessary to define the language semantics of Casanova, this reflects almost directly its formal definition, while in the hard-coded version the logic of the semantics is hidden in the implementation details of the host language used to build the hard-coded version of the compiler. This result has been further backed up also by the results obtained when implementing the networking semantics of Casanova in Chapter \ref{ch:networking}, where we obtained a code size reduction of about 13 times.

\subsection{Performance trade-off}
\label{subsec:ch_conclusion_rq2}
The second research question reads:\\\\
\researchQuestion{\rqContentTwo}\\\\

The answer to this research question can also be found in Chapter \ref{ch:languages}. In Section  \ref{sec:ch_mcnv_languages_evaluation} and \ref{subsec:code_generation_discussion} we compared the running time of a sample written in Casanova implemented in Metacasanova with respect to the same sample implemented in Python, which is a programming language used to script the game logic in several games. The running time of Casanova results to be 3 times slower than the same implementation in Python in a simulation with 1000 entities. This performance loss does not make this version of Casanova suitable for game development as such number of entities can normally be present during the execution of a game. Usually a target value for the frame rate of a game is in the order of 60 frames/second, while the simulation in Casanova runs at roughly 28 frames/second. To this we add the fact that we are running the game logic separately from the rendering phase, which introduces additional overhead. The same simulation in Python runs at about 70 frames/second. At this point we can observe that Metacasanova is suitable for the fast prototyping of a domain-specific language for game development (because of the code length reduction) but not for its use.
\newpage

\subsection{Optimization}
\label{subsec:ch_conclusion_rq3}
The third research question reads:\\\\
\researchQuestion{\rqContentThree}\\\\

In Chapter \ref{ch:functors} Sections \ref{sec:ch_functors_idea}, \ref{subsec:ch_functors_casanova_example}, and \ref{subsec:ch_functors_inlining} we identified the main cause of performance loss in the dynamic lookups that the language must perform at run time to retrieve the values of the entity fields and variables from the meta-data structures used to represent the memory model of a Casanova program. Thus, even if Casanova is a statically-typed language, in its meta-compiled version it exhibits dynamic behaviours. The reason of this is that Metacasanova, with the features presented up to Chapter \ref{ch:languages}, cannot embed the type system of a language implemented in it in its own type system, thus the typing rules of Casanova must be implemented in terms of rules in natural semantics that are evaluated at runtime. The same applies to the representation of Casanova entities: even if their structure is known at compile-time and does not dynamically change at runtime, the access to the data-structure used to encode them must be a lookup performed at runtime, while, if this could be known by Metacasanova during the compilation phase, the code for these accesses could be inlined, thus improving the runtime performance.

In order to overcome this problem we proposed in Section \ref{sec:ch_functors_modules_functors} a language extension for Metacasanova introducing \textit{functors} and \textit{modules} in the meta-language. One use of this language extension is the ability of embedding the type system of a language implemented in Metacasanova (\textit{embedded language}) in the very same type system of Metacasanova itself. In this way the type checker of Metacasanova is, at the same time, able to statically type check both the abstractions of the meta-language and those of the embedded language itself. This has a dual benefit: (\textit{i}) the typing of a program written in an language embedded in Metacasanova can always be performed statically by the type checker of Metacasanova, and (\textit{ii}), in presence of data structures that do not change their structure at runtime, it is possible to inline the access to their components at compilation time.

In Section \ref{sec:ch_functors_record_implementation} we provided a proof of such capabilities by giving an implementation of records using functors and modules to, at the same time, define the type of a record in term of the meta-type system of Metacasanova and to build getters and setters for its fields by inlining the calls to functions that are directly able to access or modify the requested field. In Section \ref{sec:ch_functors_evaluation} we compared the access to this record implementation with its dynamic counterpart used to model Casanova entities in Chapter \ref{ch:languages} obtaining performance 11 times faster with the functor implementation.

In Chapter \ref{ch:functor_languages} we show how to use functors and modules to implement the semantics of updating the entities of a Casanova program by starting from the observation that its structure is known at compile time and thus the update will always follow the same pattern. It is thus possible to build the functions necessary to update a specific Casanova program at compile time with Metacasanova, getting rid of all the dynamic checks needed to perform the same activity in the implementation provided in Chapter \ref{ch:languages}. The Casanova performance implemented in this way is 42 times faster on average than its previous implementation without functors.

We can thus conclude that this optimization leads to a performance improvement that makes a domain-specific language for games implemented in Metacasanova have acceptable performance, as now the frame rate of a Casanova program with 1000 entities is roughly 900 frames/second, against the previous version that ran at 28 frames/second.

\section{Answer to the problem statement}
\label{subsec:ch_conclusion_problem_statement}
The problem statement reads:\\\\
\problemStatement{\psContent}\\\\

Our goal in this thesis was to reduce the effort of developing a compiler for a domain-specific language for game development and, at the same time, evaluate the feasibility of such approach performance-wise. For this purpose, we designed Metacasanova, a meta-compiler whose meta-language is based on natural semantics. Metacasanova benefits in terms of development speed manifested almost immediately, as the first re-implementation of the Casanova language was substantially shorter than its hard-coded counterpart in F\#. This result is further backed up by an analogous code reduction size when implementing the networking extension. Moreover, the structure of the formalization of the language semantics was almost entirely preserved in the Metacasanova implementation, while in the hard-coded version of the compiler this is lost. However, these benefits came at a cost, since the runtime performance of a Casanova program turned out to be slower than Python, thus making the use of a DSL implemented in Metacasanova impractical for game development. We overcame this drawback by extending the meta-language of Metacasanova with functors and modules that allow to perform code generation optimizations, thus improving also the performance of the Casanova implementation that now runs 42 times faster than the previous version. We can conclude that such performance boost makes Metacasanova suitable not only for rapid prototyping a DSL for game development, but also to produce a language version that can be used in practical applications.

\section{Future Work}
\label{sec:ch_conclusion_future_work}
Metacasanova comes with a series of features that boost the development speed of a domain-specific language for game development with respect to its typing and semantics. Little effort was put into providing a way of defining the syntax of such language in Metacasanova. In all the examples presented in this work we wrote the programs of the programming language implemented in Metacasanova in terms of the meta-language itself. This of course is not ideal because, in the current state, the programmer must be expert of both this programming language and the meta-language of Metacasanova. Metacasanova should thus be extended also to support a way to define a syntax definition in a parser that generates a representation of the program in terms of the meta-language of Metacasanova.

Another interesting research aspect regarding the optimization of Metacasanova would involve the memoization of function calls: a lot of the overhead of the evaluation of rules of natural semantics goes into the pattern matching of the input parameters and of the result of the premises. Since Metacasanova is referentially transparent (unless an evaluation rule contains calls to external code), it would be possible to store the result of the evaluation of a rule in a lookup table and retrieve it if the same call is performed at a later stage instead of recomputing it every time, thus getting rid of much of the costs of pattern matching.

Finally, in this work we focused our attention on using functors and modules in Metacasanova to improve the performance of a domain-specific language for game development, and in particular to improve the performance of accessing the fields of an entity in Casanova and optimize its update, but we argue that the same approach could be used in general to optimize the compilation of any programming language. Of course this, for now, it is just a conjecture that requires further investigation by building a set of different and more diverse domain-specific languages.

\begin{comment}
\section{The Future Role of Meta-compilers}
\label{sec:ch_conclusion_future}
Meta-compilers have been so far relegated to the role of language prototyping, mainly in academic research projects where the need for a fast development tool for languages is paramount. In our vision, meta-compilers should and will play a more dominant role in different fields. One possible field of application for such tools is that of teaching programming. Since meta-compilers offer such a speed-up in the development of a programming language, and at the same time they contain a clear and flexible definition of the language type system and semantics, they can be used to build interactive tools to be used in didactic activities. Programming is a hard activity with which we all struggle even if we have been practiced it for many years. This struggle is even greater for university-level students who possess little or no knowledge of programming from their previous education. Traditionally programming is taught by explaining the theory behind a chosen programming paradigm which is later tested in practice through assignments that ask to implement the solution of ``simple'' problems in a programming language. Unfortunately, for many students the learning curve of this approach is gargantuan since a text editor and a compiler do not offer any form of hint or feedback if the student gets stuck or commits a mistake. Moreover, the errors reported by the parser or type checker of a compiler are hardly user-friendly and sometimes cryptic. With a meta-compiler it would be possible to build a tool that is able to provide real-time feedback, information on the execution, and even suggestions about the solution implemented by each student by exploiting information from its typing and semantics defined in the meta-program.

Another interesting field of application is web development. Web development is often mistakenly considered as an arid and simple field of computer science, but this could not be farther from the truth. Web development combines together a huge number of different components, such as user interfaces, networking, and database queries. Usually the interoperability of these components is granted by complex libraries, such as ASP.NET, that try to solve at API-level what could be instead solved at language-level by creating a dedicated domain-specific language for the definition of a user interface, the generation of database queries for a web site, and to express the network communication. Without the use of a meta-compiler, implementing a dedicated language for each aspect of developing a web application would be impractical, as several companies would not be able to afford the cost necessary to complete the task. A meta-compiler instead could reduce the development cost of such languages and make possible the definition of domain-specific languages thought for web applications.
\end{comment}

