In this appendix we will show in detail some operations on lists built on top of what presented in Section \ref{sec:ch_background_template_metaprogramming} that can be built by using meta-programming in C++ templates. The goal of this appendix is to convince the reader about the level of complexity of using C++ templates to express meta-programming and why it is preferable to use a dedicated meta-compiler.

\section{Element Getter}
\label{sec:app_templates_getter}
Accessing the n-th element of a list defined with templates mimics the behaviour of the its definition in a functional programming languages given below:

\begin{lstlisting}
let rec nth (n : int) (l : List<'a>) : 'a =
  match l,n with
  | x :: xs,0 -> x
  | x :: xs,_ -> nth (n - 1) xs
\end{lstlisting}

\noindent
The recursion base case is when the index we want to access is 0, which means that we want to access the head of the list. In this case we simply return the head by decomposing the list through pattern matching. In the other case we simply make a recursive call by passing the index decreased by 1 and the tail of the list. In template meta-programming, this is translated into a template that performs the same task:

\begin{lstlisting}
template <typename List> struct Nth<LST, 0> 
{
    typedef typename List::Head result;
};
\end{lstlisting}

\noindent
As shown in Section \ref{sec:ch_background_template_metaprogramming}, the arguments of the function are passed as arguments of the template itself. This version of the template is specialized for the integer 0, which corresponds to the base case of the recursion. The general case of the recursion has a dedicated template as follows:

\begin{lstlisting}
template <typename List, int N> struct Nth 
{
    typedef typename List::Tail Tail;
    typedef typename Nth<Tail, N - 1>::result result;
};
\end{lstlisting}

\noindent
The template contains a type definition for the parameter corresponding to the list tail and another type definition corresponding to the recursive call to another \texttt{Nth} template, this time containing only the tail of the list and the counter decreased by 1. To test this we can use the following sample:

\begin{lstlisting}
template <int N> struct Int 
{
  static const int result = N;
};

typedef List<Int<1>, List<Int<2>, List<Int<3>>>> testList;

int main()
{
  cout << Nth<testList, 2>::result::result << endl;
}
\end{lstlisting}

\noindent
Note that we need to access \texttt{result} twice, because the first \texttt{result} is the type of the head of the list generated by template, which is \texttt{Int}. So calling 

\begin{lstlisting}
Nth<testList, 2>::result
\end{lstlisting}

\noindent
returns \texttt{Int}, that is a type. If we want to access the value stored in \texttt{Int} then we must access the constant integer \texttt{result} contained in it. Note that if we try to access an invalid index in the list, the compiler will complain because it will try to generate a template with the tail of a list that does not exist. In this way something that in a normal program becomes a runtime error is here treated as a compilation error.

\section{Element Existence}
\label{sec:app_templates_existance}
The code that tests the existence of an element within a list is recursive as well and mimics the behaviour of its functional counterpart:

\begin{lstlisting}
let exists (element: 'a) (l : List<'a>) : 'a =
  match l with
  | [] -> false
  | x :: xs when element = x -> true
  | x :: xs -> exists element xs
\end{lstlisting}

\noindent
The function returns \texttt{false} as a base case when the list is empty, because it means that the whole list has been examined and the element has not been found. The second case is when the head of the list matches the element, which returns \texttt{true}. The last case is used when the head of the list does not match the element, thus we call recursively \texttt{exists} on the tail. In order to implement this function with C++ templates, we need to define two utility templates able to compare two elements:

\begin{lstlisting}
template <class X, class Y> struct Eq { static const bool result = false; };
template <class X> struct Eq<X, X> { static const bool result = true; };
\end{lstlisting}

\noindent
The first template has a result set to \texttt{false} when its arguments are different, while the second template is a specialization of the first one where both the first template argument and the second are the same and its result is \texttt{true}. With this utility templates we can correctly compare the values of a list defined with templates and define the recursive template for the existence function:

\begin{lstlisting}
template <class Element, class List> struct Exists
{
  static const bool result = 
    Eq<Element, typename List::Head>::result || Exists<Element, typename List::Tail>::result;
};

template <class Element> struct Exists<Element, NIL>
{
  static const bool result = false;
};
\end{lstlisting}

\noindent
The first template is the general case of the recursion. It uses \texttt{Eq} to test the value of the searched element against the head of the list. It then combines this result with the logical or on \texttt{Exists} run with the remaining tail of the list. The second template is the base case and contains a constant set to \texttt{false}. This corresponds to the base case of the recursive function above.