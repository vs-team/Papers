%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% short-courses_template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section we discuss the general template around which we have structured our short-courses. Before presenting the template, though, we must briefly discuss the purpose of our initiative; in particular, our goals are:
\begin{itemize}
\item interesting students with engaging applications, not just theory
\item showing students real CS tools and techniques for solving actual problems
\item simplifying the problems (to make them solvable in a short time) but without dumbing them down; we *must not* give the impression that CS deals with trivial matters and is somewhat ``inferior'' to maths or engineering
\end{itemize}

Our template for short-courses requires following these steps:
\begin{enumerate}
\item we choose a concrete field of research or application, such as computer graphics, physics simulations, artificial intelligence, security, computer vision, and many others. Any field which has at least one interesting practical application is suitable for our framework;
\item we pick an aspect that is relevant to the field; this aspect can be anything from the accuracy of the simulation to the security of a computer network to the ``smartness'' of an AI, etc. as long as it is easy to visually compare different solutions to see which one is better;
\item we pick a sequence of algorithms, equations or techniques that are designed to improve the parameter (2) with various degrees of complexity and quality of the solution. Ideally, this sequence should be a chain where each algorithm improves the  previous one by adding some complexity, that is each step should be strongly linked to its predecessor and successor;
\item we build a framework which hides all the implementation details that are not strictly relevant to building the various algorithms of (3); this framework should also implement the visualization system. The framework must be built so that the various algorithms of (3) can be plugged in it by the students, if possible even more than one at a time to directly compare them
\item we build the first algorithm of (3) in our system and we document it fully to offer a working starting point to the students
\item we discuss and explain (with a mix of frontal lessons and notes) the underlying theory of the various algorithms of (3) and let the students translate that theory into code that works with the framework (4)
\end{enumerate}

The choice of the actual tools used to implement this template is an important one. There are many valid alternatives, but we believe that the environment used must fulfill the following requirements:
\begin{itemize}
\item it must support advanced rendering and visualization
\item it must support syntactically simple programming languages
\item it should offer auto-completion and helpful error messages (a need eloquently motivated by \cite{SICSC})
\end{itemize}

We have used Microsoft Visual Studio 2010 \cite{VISUAL_STUDIO} with F\# \cite{F_SHARP} and XNA \cite{XNA}. F\# is a functional programming language that belongs to the .Net framework and which can access an extremely large number of mature libraries that can be used for our purposes; F\# is a dialect of the ML family, one of the three large families of functional languages (the other two being LISP and Haskell). It is important to take notice that functional languages are not a requirement of our template: scripting languages such as LUA or Python could arguably be used given their terseness. XNA is a computer graphics library that allows both high-level coding of games and simulations and which also allows in-depth access to the GPU to implement advanced rendering algorithms. XNA has been used in another experimental teaching initiative, as described in \cite{GAME_PROG_FACULTY}: we report similar experiences to theirs, namely that XNA is a powerful framework for teaching that allows students to build interactive applications that can be at any point of the spectrum that goes from simple to program to very complex but visually stunning.

Using these powerful tools has a small downside: some time must be taken, before asking students to operate these tools, to learning the bases of the chosen programming language and environment. F\# offers an immediate console which allows students to experiment with the basic language constructs as the instructor explains them, in order to quickly come to terms with the language.
