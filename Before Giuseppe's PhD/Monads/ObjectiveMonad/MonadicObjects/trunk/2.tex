% Generated by GrindEQ Word-to-LaTeX 2008 
% ========== UNREGISTERED! ========== Please register! ==========
% LaTeX/AMS-LaTeX

\documentclass[a4paper]{article}
\usepackage{anysize}
\marginsize{1cm}{1cm}{1cm}{1cm}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[dvips]{graphicx}
\usepackage{listings}
\lstset{language=haskell}
\lstset{commentstyle=\textit}
\lstset{mathescape=true}
%\lstset{labelstep=1}
%\lstset{backgroundcolor=,framerulecolor=}
\lstset{backgroundcolor=,rulecolor=}
\linespread{2.0}

\begin{document}

%%% remove comment delimiter ('%') and select language if required
%\selectlanguage{spanish} 

\noindent 
\section{Subtyping Heaps and References}

\noindent Let us consider the types of the references of the example above, given $Heap\ h_0\ ref$ for some initial heap $h_0$ and some reference type$\ ref$:

\begin{lstlisting}
i : ref (New $h_0$ Int) Int
s : ref (New (New $h_0$ Int) String) String
\end{lstlisting}

The heap $h_0$ is the starting heap at the beginning of the program. If the program is used as a ``main'', that is it is just launched, then $h_0$ will be an empty heap; in other cases, like using our computation inside another, larger computation, will mean that  $h_0$ will be the current heap that is available where the example is launched.

\noindent Now let us consider the two statements:

\begin{lstlisting}
v $\leftarrow$ s
x $\leftarrow$ i
\end{lstlisting}

These two are incompatible, since the first statement forces our monad to be of type $ref\ \left(New\ \left(New\ h_0\ Int\right)\ String\right)$ and thus this type will have to be in all subsequent statements of the same monadic program, but the second statement expects our monad to be of type $ref\ \left(New\ h_0\ Int\right)$. This is absolutely reasonable on the part of the type system, but it is quite unacceptable given our circumstances: why cannot we use a reference that refers to a smaller heap where we have a larger heap available? Indeed, all the values that reference $i$ requires are available (plus some more that are irrelevant to $i$) in the heap that we have when the reference $s$ is in scope. It would be interesting to make it possible to use a reference that requires a smaller (less defined) heap when a larger (more specified) heap is available. This kind of notion is clearly a notion of subtyping between heaps and references.

\noindent To define a subtyping relationship between heaps, let us start by giving a subtyping predicate:

\begin{lstlisting}
Subtype $\alpha$ $\beta$
\end{lstlisting}

Which for brevity we will also write

\begin{lstlisting}
$\alpha$ $\le$ $\beta$
\end{lstlisting}
The fact that $\alpha $ is a subtype of $\beta $ implies that $\alpha $ is more specified than $\beta $, and as such it may be used in any context where a $\beta $ is expected. For this reason we also give a casting (or coercion) function that converts from a value of type $\alpha $ to a value of its supertype $\beta $:

\begin{lstlisting}
downcast :$\alpha$ $\to$ $\beta$
\end{lstlisting}
We also know that the subtyping relation is reflexive and transitive, so we will add these rules as instances of the subtyping predicate:

\begin{lstlisting}
Subtype $\alpha$ $\alpha$ downcast=$\lambda$ x.x
\end{lstlisting}

\begin{lstlisting}
Subtype $\alpha$ $\beta$ $\wedge$ Subtype $\beta$ $\gamma$ $\Rightarrow$ Subtype $\alpha$ $\gamma$ downcast=downcast $\circ$ downcast
\end{lstlisting}

Since we are mostly interested in subtyping between references, when is it safe to downcast them? As already discussed, a first criterion for downcasting a reference is that the heap $h$ that the reference manipulates is actually smaller than the current heap; this means that:

\begin{lstlisting}
Heap h ref $\wedge$ Heap $h'$ ref $\wedge$ $h'$ $\le$ h $\Rightarrow$ ref h $\alpha$ $\le$ ref $h'$ $\alpha$
\end{lstlisting}

This means that references are contravariant with respect to their heap. Also, the second argument of references allows for the intuitive kind of conversion:

\begin{lstlisting}
$\alpha$ $\le$ $\alpha'$ $\Rightarrow$ ref h $\alpha$ $\le$ ref h $\alpha'$
\end{lstlisting}

This second rule shows that a reference to a value $\alpha $ behaves exactly like that value, thereby allowing conversions that mirror the behavior of the value that our reference is standing for.

These rules are quite hard to concretely instance. This is why we will not be able to instance these rules once and for all in a highly parametric fashion, but instead we will just give some specific instances that are of particular use to us when we are dealing with concrete heaps and references. Also, we will mostly deal with subtyping between values and not subtyping between functions.

At this point we can rewrite the ``incriminated'' example above so that it compiles:

\begin{lstlisting}[frame=tb,mathescape]{somecode}
$ex_2'$ =
	do 10 $>>=$ ($\lambda$i.
	do "hello " $>>=$ ($\lambda$s.
	do s *= ($\lambda$x.x++"world")
	   let $i'$ = downcast i
	   v$\leftarrow$eval s
	   x$\leftarrow$eval $i'$
	   return v ++ show x))
\end{lstlisting}

Now the type of $ex_2'$ will not only reflect the type of the result of the computation, but also the requirement of subtyping between heaps built with the $New$ type operator:

\begin{lstlisting}
Heap $h_0$ ref $\wedge$ ref (New $h_0$ Int) Int $\le$ ref (New (New $h_0$ Int) String) Int $\Rightarrow$ $ex_2'$ : ref $h_0$ String
\end{lstlisting}

\end{document}

% == UNREGISTERED! == GrindEQ Word-to-LaTeX 2008 ==

