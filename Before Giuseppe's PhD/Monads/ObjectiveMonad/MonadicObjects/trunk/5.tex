% Generated by GrindEQ Word-to-LaTeX 2008 
% ========== UNREGISTERED! ========== Please register! ==========
% LaTeX/AMS-LaTeX

\documentclass[a4paper]{article}
\usepackage{anysize}
\marginsize{1cm}{1cm}{1cm}{1cm}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{listings}
\lstset{language=haskell}
\lstset{commentstyle=\textit}
\lstset{mathescape=true}
%\lstset{labelstep=1}
%\lstset{backgroundcolor=,framerulecolor=}
\lstset{backgroundcolor=,rulecolor=}
\linespread{2.0}

\begin{document}

%%% remove comment delimiter ('%') and select language if required
%\selectlanguage{spanish} 

\noindent 
\section{Running the Examples}

\noindent Having a concrete implementation means that now we can try and run the examples of which we only listed the code and gave the type. Let us start with:

\begin{lstlisting}
$ex_1$ = eval i >>= ($\lambda$v. i := (v $\times$ 10) >> eval i)
\end{lstlisting}

We wish to evaluate the term $runST\ ex_1\ (5:Nil)$, assuming that:

\begin{lstlisting}
i=Reference ($\lambda$ h.(hRead h (_:Z),h)) ($\lambda$ v.$\lambda$ h.( (),hWrite v h (_:Z)))
\end{lstlisting}

the resulting evaluation is:

\begin{lstlisting}
= runST (eval i >>= ($\lambda$v. $\dots$ )) (5:Nil) \ 
= runST ((ST $\lambda$h.(hRead h (_:Z),h)) >> =($\lambda$v. $\dots$ )) (5:Nil) \ 
= runST (i := 5 $\times$ 10 >> $\dots$ ) (5:Nil) \ 
= runST ((ST $\lambda$h.((),hWrite 50 h (_:Z))) >> $\dots$ ) (5:Nil) \ 
= runST (eval i) (50:Nil) \ 
= runST (ST $\lambda$h.(hRead h (_:Z),h)) (50:Nil) \ 
= 50
\end{lstlisting}

This is exactly the result we would have expected. Also notice that for all practical purpose our programs act as if exactly one heap is accessible at all times. Depending on the capabilities of the runtime this might also be essentially true, as most of the parts of a heap could be shared thanks to the immutability of the data structures of the various heaps which are allocated with various shared parts.

\noindent Let us now consider our second example:

\begin{lstlisting}[frame=tb,mathescape]{somecode}
$ex_2'$ =
	do 10 $>>=$ ($\lambda$i.
	do "hello " $>>=$ ($\lambda$s.
	do s *= ($\lambda$x.x++"world")
	   let $i'$ = downcast i
	   v$\leftarrow$eval s
	   x$\leftarrow$eval $i'$
	   return v ++ show x))
\end{lstlisting}

We will evaluate this as if it were a program launched all by itself (that is with an empty heap and no external references), by evaluating the term $runST\ ex_2'\ Nil$; we will evaluate this term with a (simpler) small-step semantics that refers to the effect our statements have on the heap and the various bound variables:

\begin{tabular}{|p{1.1in}|p{0.2in}|p{0.7in}|p{0.2in}|p{0.7in}|p{1.0in}|} \hline 
Statement & i & s & x & v & Heap \\ \hline 
ex\_2\^{}'=do 10$\gg $+($\lambda $i. & - & - & - & - & 10::Nil \\ \hline 
do(\_ \^{}'')hello\^{}''$\gg $+($\lambda $s. & 10 & ``Hello'' & - & - & ``Hello''::10::Nil \\ \hline 
do s*=($\lambda $x.x++\^{}'' world\^{}'' ) & 10 & ``Hello World'' & - & - & ``Hello World''::10::Nil \\ \hline 
let i\^{}'=downcast i & 10 & ``Hello World'' & - & - & ``Hello World''::10::Nil \\ \hline 
 v?eval s & 10 & ``Hello World'' & 10 & ``Hello World'' & ``Hello World''::10::Nil \\ \hline 
 x?eval i' & 10 & ``Hello World'' & 10 & ``Hello World'' & ``Hello World''::10::Nil \\ \hline 
 return v++show x)) & - & - & - & - & Nil \\ \hline 
\end{tabular}



\noindent The returned result is (as expected) $"10Hello\ World"\ $.

\noindent 

\noindent 

\noindent 

\noindent 


\end{document}

% == UNREGISTERED! == GrindEQ Word-to-LaTeX 2008 ==

