% Generated by GrindEQ Word-to-LaTeX 2008 
% ========== UNREGISTERED! ========== Please register! ==========
% LaTeX/AMS-LaTeX

\documentclass[a4paper]{article}
\usepackage{anysize}
\marginsize{1cm}{1cm}{1cm}{1cm}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[dvips]{graphicx}
\usepackage{listings}
\lstset{language=haskell}
\lstset{commentstyle=\textit}
\lstset{mathescape=true}
%\lstset{labelstep=1}
%\lstset{backgroundcolor=,framerulecolor=}
\lstset{backgroundcolor=,rulecolor=}
\linespread{2.0}

\begin{document}

\title{Customizable Objects}

\textit{Giuseppe Maggiore}
\textit{Michele Bugliesi}
\textit{UniversitÃ¡ Ca'  Foscari -- Venice}

\section{Motivation}

We wish to introduce a series of constructs that allow us to write object-oriented programs that are capable of running with
very different runtime behaviors with minimal to zero modification of the program. Our constructs (characterized by a type 
class $Heap$) are:
\begin{itemize}
\item a storage (heap) $h$
\item a reference to a location in the storage $ref$
\item an allocation operator $>>+$ for values inside the heap
\item a program statement $st$
\item an evaluation operator $eval$
\item an assignment operator $:=$
\item a selection operator for fields and methods $\Leftarrow$
\end{itemize}

We also give a subtyping and an inheritance relation for polymorphism.

Thanks to these constructs we can write generic object-oriented programs. We show how different concrete implementations
of the $Heap$ class can be given that allow highly varying execution schemes.

The first execution scheme is a simple mutable program that manipulates references to $Point3D$, which inherits from $Point2D$:
\begin{lstlisting}[frame=tb,mathescape]{somecode}
length2d : Label Point2D (Method Point2D Unit Float)
length3d : Label Point3D (Method Point3D Unit Float)
normalize : Label Point3D (Method Point3D Unit Unit)

f : Heap h ref st, Point3D $\le$ Point2D $\Rightarrow$ ref h Point 3D $\to$ st h float
f p = 
  do  l $\leftarrow$ (p $\Leftarrow$ length3d) ()
      (p $\Leftarrow$ normalize) ()
      l' $\leftarrow$ (p $\Leftarrow$ length2d) ()
      return l / l'

v = runMutable (do (newPoint3D 1.0 2.0 -1.0) >>+ f)
\end{lstlisting}

In this example $v$ will be equal to the original length of the vector divided by the length of the $x,y$ vector after normalizing it in three
dimensions.

As another example let us consider some code that performs operations on a bank account. This code makes us of an extension to our
system, that is the $Transactional$ predicate on our statements that allows us to use the $beginT$, $abortT$ and $commitT$ statements
that respectively mark the beginning of a transaction and its end by failure or success:

\begin{lstlisting}[frame=tb,mathescape]{somecode}
get_balance : Label Account (Method Account Unit Int)
withdraw : Label Account (Method Account Int Unit)
deposit : Label Account (Method Account Int Unit)

banker : Heap h ref st, Transactional st $\Rightarrow$ [Int] $\to$ [Int] $\to$ ref h Account
banker ws ds account = 
  do  begintT
      transactions ws ds account
      b $\leftarrow$ (account $\Leftarrow$ get_balance) ()
      return b
  where transactions [] [] =
          do  b $\leftarrow$ (account $\Leftarrow$ get_balance) ()
              if b < 0 then abortT
              else commitT
        transactions (w:ws) [] = 
          do  (account $\Leftarrow$ withdraw) w
              transactions ws []
        transactions ws (d:ds) = 
          do  (account $\Leftarrow$ deposit) d
              transactions ws ds

v = runMutable (do (newAccount 100) >>+ banker [10;5;700] [200;500;240])
\end{lstlisting}

where we expect that the transaction will fail and $v = 100$.

We can also express concurrent computations where assignment corresponds to sending a value and evaluation corresponds to
receiving one from a network channel; the $Concurrent$ predicate also allows us to use the $fork$ and $sleep$ statements:

\begin{lstlisting}[frame=tb,mathescape]{somecode}
main : Heap h ref st, Concurrent st $\Rightarrow$ st h ()
main = 
  0 >>+ ($\lambda$channel.
      fork (p1 channel 0)
           (p2 channel))
  where p1 channel i =
          do  channel := i -- send
              sleep 1000
              i' $\leftarrow$ eval channel -- receive
              p1 channel (i'+1)
        p2 channel =
          do  i $\leftarrow$ eval channel -- receive
              channel := (i*2)
              p2 channel

runConcurrent main
\end{lstlisting}

where we expect the code to never stop running while the two processes continuosly exchange messages.

Finally we show how we can express reactive programs that are capable of automatically updating certain values where those they depend from get modified;
the $Reactive$ predicate enables the reactive operators $!=$ for assignment and $!+$ for sum:

\begin{lstlisting}[frame=tb,mathescape]{somecode}
f : Num a, Heap h ref st, Reactive ref $\Rightarrow$ ref h a $\to$ ref h a $\to$ ref h a $\to$ st h a
f a b c =
  do  b := 10
      c := -5
      a != b !+ c
      x $\leftarrow$ a
      b := 5
      x' $\leftarrow$ a
      return (x,x')

v = runReactive (do 0 >>+ ($\lambda$a.0 >>+ ($\lambda$b.0 >>+ ($\lambda$c.f a b c))))
\end{lstlisting}

where we expect our program to return (5,0) since reassigning $b$ automatically modifies the value of $a$ which depends from it.

These are by no means the only possible applications of our system. Not only these can be combined (for example to form transactional and
concurrent programs) through monad transforms, but also many more applications could be found.

\end{document}

% == UNREGISTERED! == GrindEQ Word-to-LaTeX 2008 ==

