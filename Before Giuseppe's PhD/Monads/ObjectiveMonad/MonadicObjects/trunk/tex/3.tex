% Generated by GrindEQ Word-to-LaTeX 2008 
% ========== UNREGISTERED! ========== Please register! ==========
% LaTeX/AMS-LaTeX

\documentclass[a4paper]{article}
\usepackage{anysize}
\marginsize{1cm}{1cm}{1cm}{1cm}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[dvips]{graphicx}
\usepackage{listings}
\lstset{language=haskell}
\lstset{commentstyle=\textit}
\lstset{mathescape=true}
%\lstset{labelstep=1}
%\lstset{backgroundcolor=,framerulecolor=}
\lstset{backgroundcolor=,rulecolor=}
\linespread{2.0}

\begin{document}

%%% remove comment delimiter ('%') and select language if required
%\selectlanguage{spanish} 

\noindent 
\section{A Concrete Implementation}

\noindent We now give a first implementation of these constructs. Our first goal is to write a heap and a reference that allow us to manipulate the heap in a stateful fashion. Since our heap is strongly typed, our first need is a collection of heterogeneous values where values may be added to the list; this kind of collection can be easily implemented with heterogeneous lists accessed with compile-time Church Numerals. Our implementation is based on that of \dots 

\noindent Note that we never use ``regular'' lists in our system. For this reason we have decided to borrow the notation where $::$ is the list constructor since we will not need it elsewhere. Also, in this context we will use the same symbols twice: once for values and once for types; we advise the reader to be always aware of the context in which these operators are used since the context will make it clear which one of the symbols is currently in use. We believe that having two distinct sets of symbols in the end would reduce the readability of our code and so we only used distinct symbols in the actual implementation.

\noindent A heterogeneous list can be built using two type constructors, one for the empty heterogeneous list and one for adding a new head to an existing heterogeneous list:

\begin{lstlisting}
Nil=Nil
h::tl=h::tl
\end{lstlisting}

We characterize heterogeneous lists not by their type (that would be impossible since heterogeneous lists all have very different types), but rather with the $HList $inductive predicate:

\begin{lstlisting}
HList Nil
HList tl $\Rightarrow$ HList (h::tl)
\end{lstlisting}

This means that the empty heterogeneous list is a heterogeneous list, and by adding an element of any type $h$ to a heterogeneous list we obtain a new heterogeneous list.

\noindent Heterogeneous lists are accessed by index. To make accesses type safe we need to ensure that no integer that would result in an impossible access (index out of range) is ever used to access a list. For this reason we implement compile-time Church Numerals at the type level, and we use those to access our heterogeneous lists:

\begin{lstlisting}
Z=Z
S n=S n
\end{lstlisting}

Just like we did for heterogeneous lists we now add a $CNum $predicate to characterize all Church Numerals inductively:

\begin{lstlisting}
CNum Z
CNum n $\Rightarrow$ CNum (S n)
\end{lstlisting}


The only real difference between Church Numerals and heterogeneous lists is that while the heterogeneous list carries inside its values a series of values of different types, a Church Numeral is always empty, that is beyond a certain number of applications of its $S$ constructor it does nothing. For this reason we will never be interested in the actual value of Church Numerals, and we will only use unnamed instances of Church Numerals like in the following example:

\begin{lstlisting}
CNum n $\Rightarrow$ f : n $\to$ Nil
f (_:n)=Nil
\end{lstlisting}

Accessing a heterogeneous list is based on the $HLookup$ predicate:

\begin{lstlisting}
CNum n $\Rightarrow$ HLookup l n
\end{lstlisting}

This predicate contains a type function that tells us the type of the selected field:

\begin{lstlisting}
HAt l n : *
\end{lstlisting}

Plus two functions to read and write the n-th element of the list:

\begin{lstlisting}
hRead : l $\to$ n $\to$ HAt l n
hWrite :HAt l n $\to$ l $\to$ n $\to$ l
\end{lstlisting}

The $HLookup$ predicate is instanced inductively on the second parameter. First we instance $HLookup$ for accesses to the first item of the list (index $0$):

\begin{lstlisting}
HLookup (h::tl) Z
HAt (h::tl) Z=h
hRead (h::tl) _ = h
hWrite v (h::tl) _ =v::tl
\end{lstlisting}

Now we instance $HLookup$ for all other accesses:

\begin{lstlisting}
CNum n $\Rightarrow$ HLookup (h::tl) (S n)
HAt (h::tl) (S n)=HAt tl n
hRead (h::tl) _=hRead tl (_:n)
hWrite v (h::tl) _=h::(hWrite v tl (_:n))
\end{lstlisting}

Notice two interesting aspects about this code: first it is impossible to read anything on the empty heterogeneous list; second, it is impossible to access a heterogeneous list with an index that would be too big. As an example, consider the type of the expression:

\begin{lstlisting}
hRead (0::1::Nil)(S S S Z) : $\alpha$
\end{lstlisting}

From the definition of the $hRead$ function we know that:

\begin{lstlisting}
$\alpha$ 	= HAt (Int::Int::Nil) (S S S Z)
	= HAt (Int:Nil)(S S Z)
	= HAt Nil (S Z)
\end{lstlisting}

But the last term is stuck since there are no instances of the $HAt $type functions (being there no instances of the $HLookup$ predicate) where$ l=Nil$.

\noindent A straightforward choice for a reference type is clearly inspired by the state monad: a reference will contain a pair of functions, one for evaluating the reference from the heap and one for setting a new value for this reference on the heap:

\begin{lstlisting}
Reference h $\alpha$ = Reference (h $\to$ ($\alpha$ $\times$ h)) ($\alpha$ $\to$ h $\to$ (Unit $\times$ h))
\end{lstlisting}

The reference operations are stateful, that is the heap might be changed (its new value is returned by both the get and the set functions) even when we simply evaluate the reference. These two functions have been chosen for the simplicity with which they can be converted into statements of the state monad.

\noindent Now that we have both a candidate for heaps and references we can instance the $Heap$ predicate. We will use heterogeneous lists as typed heaps and $Reference$ as the type for our references. We start by inductively instancing the allocation operators:

\begin{lstlisting}
Heap Nil Reference
  New Nil $\alpha$ = $\alpha$ :: Nil
  new Nil x = x :: Nil
  delete (x::Nil) = Nil
\end{lstlisting}

and

\begin{lstlisting}
Heap (h::tl) Reference
  New (h::tl)$\alpha$ =h::(New $\alpha$  tl)new (h::tl)x=h::(new x tl)delete (h::tl)=h::(delete tl) \] 
\end{lstlisting}

The remaining functions needed for one heap have the same implementation for both the empty heap and a non-empty heap. For this reason we just assume that $HList h\Rightarrow Heap h$.

\noindent The evaluation operator simply returns the get function:

\begin{lstlisting}
eval (Reference get set)=ST get
\end{lstlisting}

The assignment operator invokes the set function with the given parameter and returns the resulting curried function:

\begin{lstlisting}
(Reference get set) := v = ST(set v)
\end{lstlisting}

The allocation operator $(\gg +)$ generates a temporary reference that refers to a newly allocated value in a larger heap. A function is invoked to act on this reference to generate a statement that will return the final value of the computation done on this new reference. We define this operator by steps; since the $(\gg +)$ operator requires manipulating the length of a heterogeneous list, we begin by giving the $HLength$ type function (which is part of the $HList$ type predicate):

\begin{lstlisting}
HLength l : *
HLength Nil=Z
HLength (h::tl)=S (HLength tl)
\end{lstlisting}

The first step of the actual computation is to build the new reference to access the new item, which can be looked up with an index equal to the length of the input heap:

\begin{lstlisting}
(>>+) : $\alpha$ $\to$ (Reference (New h $\alpha$) $\alpha$ $\to$ ST (New h $\alpha$) $\beta$) $\to$ ST h $\beta$
 v >>+ k = 
    let $r_{new}$ = Reference ($\lambda$h.(hRead h (_:HLength h),h))
                         ($\lambda$v.$\lambda$h.((),hWrite v h (_:HLength h)))
\end{lstlisting}

Notice how we invoke the read and write functions ($hRead$ and $hWrite$) with index equals to the length of the type of the original heap $h$. The second step consists in obtaining the result by invoking the $k$ function:

\begin{lstlisting}
    let (ST res)=k $r_{new}$
\end{lstlisting}

Finally we convert this result into the desired form by temporarily adding the new value $v$ to the heap, performing the computation and then removing the value:

\begin{lstlisting}
    in ST($\lambda$h.downcast(res(new h v))  where downcast (x,h)=(x,delete h)
\end{lstlisting}


\noindent 


\end{document}

% == UNREGISTERED! == GrindEQ Word-to-LaTeX 2008 ==

