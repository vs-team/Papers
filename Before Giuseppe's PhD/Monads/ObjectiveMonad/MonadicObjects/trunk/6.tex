% Generated by GrindEQ Word-to-LaTeX 2008 
% ========== UNREGISTERED! ========== Please register! ==========
% LaTeX/AMS-LaTeX

\documentclass[a4paper]{article}
\usepackage{anysize}
\marginsize{1cm}{1cm}{1cm}{1cm}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{listings}
\lstset{language=haskell}
\lstset{commentstyle=\textit}
\lstset{mathescape=true}
%\lstset{labelstep=1}
%\lstset{backgroundcolor=,framerulecolor=}
\lstset{backgroundcolor=,rulecolor=}
\linespread{2.0}

\begin{document}

%%% remove comment delimiter ('%') and select language if required
%\selectlanguage{spanish} 

\noindent 
\section{Mutable Records}

\noindent Up until now we have defined a very general form of a heap with mutable references and we have given the first concrete implementation that allows us to write and run programs that use these constructs; thanks to monads and some syntactic sugar we even obtain code that looks and feels very stateful and imperative. We now move to studying a way to define and manipulate records (which are no more than heterogeneous lists plus some definition of labels instead of Church Numeral based access) within our system.

\noindent We start by giving a new predicate to characterize record types$ r$:

\begin{lstlisting}
Heap h ref $\Rightarrow$ Record ref h r 
\end{lstlisting}

A record has a label type which takes as input an additional type parameter (the type of the selected field):

\begin{lstlisting}
Label ref h r : *$\to$ * 
\end{lstlisting}

From a reference to a record and a label that selects a field of type $\alpha$ we can select a reference to a value of type $\alpha$ to a field inside the record:

\begin{lstlisting}
$\Leftarrow$  : ref h r $\to$ Label ref h r $\alpha$ $\to$ ref h $\alpha$  
\end{lstlisting}

We can now say that our heterogeneous lists are records, and labels are a pair of functions similar to how references store a get and a set function:

\begin{lstlisting}
Label r $\alpha$ =Label (r$\to$ $\alpha$)  (r$\to$ $\alpha$ $\to$ r)
\end{lstlisting}

We also need a function to convert a Church Numeral into a label:

\begin{lstlisting}
CNum n $\wedge$ HList h $\Rightarrow$ labelAt : n $\to$ HAt h n
labelAt _ = Label ($\lambda$h.hRead h) (_:n($\lambda$h.$\lambda$v.hWrite v h (_:n)))
\end{lstlisting}

We can now instance the $Record$ predicate:

\begin{lstlisting}
Heap h ref $\wedge$ HList r $\Rightarrow$ Record ref h r
    Label ref h r $\alpha$ = Label r $\alpha$
    (Reference get set) $\Leftarrow$ (Label read write) = 
            Reference (do r $\leftarrow$ get
                               return (read r))
                             ($\lambda$ v.do r $\leftarrow$ get
                                     set (write r v))
\end{lstlisting}

The selection operator simply does some packing and unpacking of the label into a reference.

\noindent At this point we could consider a simple example that shows how we can use records mutably:

\begin{lstlisting}
Person = String:String:Int:Nil
name : Label Person String
name = labelAt Z
surname : Label Person String
surname = labelAt (S Z)
age : Label Person Int
age = labelAt (S S Z)

$ex_{3}$ = do ``John'':''Smith'':27:Nil >>+ ($\lambda$p.
                 do (p$\Leftarrow$age) := 25
                    let n = p$\Leftarrow$surname
                    in n*=(++'' Jr''))
runST Nil $ex_3$
\end{lstlisting}

\noindent In the example above we declare a record type ($Person$) and we name its fields with labels. At this point we dynamically allocate an instance of our record, we manipulate it by reassigning the age to $25$ and adding the $"Jr."$ String to the surname.

\noindent 

\end{document}

% == UNREGISTERED! == GrindEQ Word-to-LaTeX 2008 ==

