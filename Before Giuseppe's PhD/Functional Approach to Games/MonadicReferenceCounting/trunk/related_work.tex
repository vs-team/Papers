%----------------------------------------------------------------------------
%  related_work.tex 
%----------------------------------------------------------------------------

\subsubsection{Region-based memory management}
Tofte and Talpin \cite{8_7} present an inference system for classifying all allocated data of a program into regions and deducing a safe lifetime for each region, which enables provably memory-safe implementations of ML-like languages with-out a garbage collector. Crary et al.'s Capability Calculus \cite{8_6} extends this work by allowing explicit region allocation and deletes, while making sure that all data accesses to a region happen during its lifetime. The commonality of these systems is that only regions are treated linearly; all other objects are allocated within regions and have types akin to guarded types. Regions are not first-class values and cannot be stored in data structures.

\subsubsection{Linear type systems}
Starting with Wadler \cite{8_5}, linear types systems have been used in purely functional languages to enforce single threading on the state of the world or to implement operations like array updating without the cost of a full copy. Linear type systems enable resource management at the granularity of a single object. Every use of an object of linear type consumes the object, leading to a programming style where linear objects are threaded through the computation. Wadler's let! construct, or its variations, can be used to give a temporary nonlinear type to an object of linear type. Walker and Watkins \cite{8_8} study a type system with three kinds of objects: linear, reference counted, and region allocated. The kind of an object is fixed at allocation without a means to change kind. They provide let! only for regions.

\subsubsection{Lighweight static capabilities}
Static capabilities have been implemented by Kiselyov et al. \cite{5_3} in a lightweight fashion in modern functional languages such as OcaML and Haskell. They propose a "style" of programming with three ingredients:
\begin{itemize}
\item A compact kernel of trust that is specific  to the problem domain.
\item Unique names (capabilities) that confer rights and certify properties, so as to extend the trust from the kernel to the rest of the application.
\item Static (type) proxies for dynamic values.
\end{itemize}
The requirements imposed on the host language to implement this style are an expressive core language, higher-rank polymorphism and phantom types. Capabilities are represented as types; safety conditions are stored in types as in dependent-type programming. If a program type-checks, then the type system and the kernel of trust together verify that the safety conditions hold in any run of the program. In most cases, this static assurance costs us no run-time overhead.

\subsubsection{Lightweight Monadic Regions}
Kiselyov et al. \cite{5_1} also build a library that statically ensures the safe use of resources such as file handles. They statically prevent accessing an already closed handle or forgetting to close it. The libraries can be trivially extended to other resources such as database connections and graphic contexts. Their library supports region polymorphism and implicit region subtyping, along with higher-order functions, mutable state, recursion, and run-time exceptions. A program may allocate arbitrarily many resources and dispose of them in any order, not necessarily LIFO. These monadic regions are implemented in Haskell as monad transformers. For contrast, the authors also implement a Haskell library for manual resource management, where deallocation is explicit and safety is assured by a form of linear types. The linear typing is implemented in Haskell with the help of phantom types and a parameterized monad to statically track the type-state of resources.

\subsubsection{Strongly Typed Memory Areas}
Jones et al. \cite{5_4} discuss how to make Haskell suitable for systems programming tasks -including device driver and operating system construction. As a result of some gaps in functionality it often becomes necessary either to code some non-trivial components in more traditional but unsafe languages like C or assembler, or else to adopt aspects of the foreign function interface that compromise on strong typing and type safety. Some of these gaps may be filled by extending a Haskell-like language with facilities for working directly with low-level, memory-based data structures. The authors designed and implemented language features that allow programmers to de?ne strongly typed, high-level views, comparable to programming with algebraic datatypes, on the underlying bitdata structures. A critical detail in making this work is the ability to specify bitlevel layout and representation information precisely and explicitly; this is important because the encodings and representations that are used for bitdata are often determined by third-party speci?cations and standards that must be carefully followed by application programmers and language implementations.
