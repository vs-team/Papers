%----------------------------------------------------------------------------
%  intro.tex 
%----------------------------------------------------------------------------
Modern computer languages are very reliable when it comes to writing a large class of common, real-world applications. For example, relatively simple form applications or web sites can be built extremely easily in languages such as Java, C\# and many others. This is thanks to commonplace facilities like garbage collectors, classes and inheritance and large libraries which simplify many tasks which otherwise would be hard or error-prone. On the other hand, there is a not so small set of applications for which these languages do not perform even nearly as well; for example games, even though very powerful libraries such as XNA make them easier to write by encapsulating many useful patterns, are not so suitable for modern languages. For this reason most games are still written in C++ (sometimes even in C) and the transition to higher level languages is not happening as fast as it could. As another example we could consider mobile applications. The widespread adoption of very powerful, fully programmable smartphone like the iPhone, Google Android or Windows Phone 7 makes performance even more important to achieve: lighter applications mean much better applications where CPU cycles and battery are both scarce resources. On the other hand, to allow as many developers as possible to easily create applications for these platforms, it makes sense (as indeed it is happening) to allow programming these devices with as languages that are as high-level as possible. Finally, there are many real time or soft real time applications that migh benefit from using high level languages but which cannot afford the pauses or slowdowns that sometimes the garbage collector might require, especially on less powerful hardware.


In this paper we document the results of implementing a videogame in such a high-level language (F\#) for a mobile device. Early in our development cycle we discovered that the biggest problem of our application was that by continually allocating and deallocating instances of the same types (such as projectiles and particles) we kept triggering the garbage collector, forcing the application to a crawl everytime it started. Rather than implement object pooling, we decided to try and generalize this technique by implementing reference counting \cite{7_6} inside the state monad \cite{1_1}. The state monad contains and manages all the actual instances of the objects which require reference counting, and references to these objects can only be accessed through the state monad itself. This allowed us to track the lifetime of our entities, in a lightweight enough fashion to ensure the increase in performance that we needed and transparently enough that it became convenient to track other resource types as well, such as files or GPU memory which require manual disposal.


In this paper we discuss a possible generalization of the work described above, where in addition to a monadic reference counting system we also discuss how type-level meta-programming \cite{3_1,3_2,3_3,6_1} and the parameterized monad \cite{1_7} can be used to track the types of resources with a strongly typed heterogeneous list \cite{4_1}, thereby removing even the need for the developer to "discover" what type the state must have. Also, this system could be the stepping stone for a more refined state-tracking monad which uses type-level values and phantom types to track expected properties of the state monad at various points in the program.


An important note is about the computer language in which we have written the samples. We have used a pseudo-Haskell, and we believe our listings may be turned into a working program without too much effort. This notwithstanding, it must be noted that said effort has not been made by us: our software system is mostly interested in performance, and from the point of view of benchmarking performance Haskell may not be the best suited language given its lazy evaluation strategy. For us this pseudo-Haskell has acted as a clear and easily implementable specification, and we do not claim anything about its workability in any present or future versions of the language.
 
