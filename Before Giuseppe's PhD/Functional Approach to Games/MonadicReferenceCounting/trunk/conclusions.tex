%----------------------------------------------------------------------------
%  conclusions.tex 
%----------------------------------------------------------------------------

Modern computer languages are extremely powerful and their benefits to creating correct programs are widely accepted. Many tools used in these languages (garbage collection as the most prominent example) solve many problems and affords greater expressivity, but have a cost in terms of performance and cannot capture some interesting and useful patterns. Monads (the parametrized state monad in particular) can be a great tool for adding powerful capabilities such as memory pooling, reference counting for timely resource disposal and even additional forms of static analysis like ownership of shared variables in multiple threads, initializing variables before using them, and so on. While monads can indeed express some of these constructs very efficiently, others require further work. When building our system (in F\#) we were forced to make use of quotations to process our code before execution, thereby adding a layer of program transformation to automate certain operations that depend on the structure of the type of their parameters; for this reason we believe that the presence of Haskell-style type classes would be the ideal complement to monads for creating libraries which complexity until now has forced them to reside in the runtime of the language (the virtual machine, for example) forcing all developers to use exactly one implementation. Having a system expressive enough so that the memory management strategy can be changed from one program to the next or can even be abstracted away could lead to very interesting consequences in terms of developer freedom when using high-level languages: does one need fast and automated memory management for non-cyclic data structures? Use a reference counting library. Does one need a traditional garbage collector? Use a garbage collection library. Does one need manual memory management? Use a manual memory management library. And so on. It might also be extremely powerful to be able to write programs where various styles of resource management are mixed, according to the needs and expected execution frequencies of the various portions of code.

We believe that our system, which is in its very early stages, could be greatly extended. One obvious direction of further work is to support more forms of static analysis inside the parameterized monad, from abstract interpretation to simple state machines that govern the behavior of certain entities up to the implementation of session types. This kind of approach would greatly benefit from the experience gathered in \cite{5_1,5_2,5_3,5_4}.

An additional interesting result that we obtained is a very lightweight implementation of our state monad which actually makes use of the imperative functions of the underlying language. Thanks to this, and also thanks to massive inlining, we were able to obtain an average runtime performance between 5\% and 15\% faster than by using the .Net garbage collector and with minimal changes in the client code. This result has prompted us to start an in-depth study of all the cases where our approach is faster in order to determine its usefulness and viability.

As a side note, we believe that meta-programming (or generic programming, \cite{6_1,6_2,6_3,6_4,6_5,6_7,6_8,6_9}) might be one of the aspects that most have the potential to really make a difference when it comes to the widespread adoption of functional languages. As we have shown, meta-programming can be used not only to express very general libraries: meta-programming can also be used to optimize code, from implementing a lighter resource management system as in our case to implementing libraries that perform algorithmic optimizations (like those known from relational algebra) when doing list processing. In short, meta-programming could really be what makes it possible to build programs in functional languages that not only are safer, but also much faster thanks to the ability to meta-program optimization algorithms and various other policies.


