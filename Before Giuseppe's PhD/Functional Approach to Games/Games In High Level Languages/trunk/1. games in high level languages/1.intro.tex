%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% intro.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Video-games touch many of the fields of computer science. Video-games are heavy in:
\begin{itemize}
\item maths and physics: from the projective algebra and lighting models used in rendering to the physical simulations that make a virtual world feel more ``real"
\item algorithms: we find balanced spatial trees for efficiently querying the world for objects based on a position to pathfinding algorithms for automated navigation of the game environment
\item optimization: games must run fast, or the user loses the feeling of immersion because of stuttering; no CPU cycles should be wasted
\item networking: multiplayer games implement both client-server and peer-to-peer architectures in order to synchronize the game state across a network
\item abstraction: to allow for ``scripting", that is layering custom behaviors on top of the basic architecture, games must support a programmable interface (sometimes with an entire interpreter for an external scripting language)
\end{itemize}
Most games are written in relatively low-level languages such as C/C++. These languages allow the writing of complex applications that can run very fast thanks to the careful hand-crafted management of hardware resources; while this is certainly a good thing, the amount of effort required on the part of programmers is much higher than it could be. In this paper we will discuss the general architecture of a game, and how the various problems encountered when building a small game can be solved.

\subsection{General shape of a game}
A game requires at the very least two functions:
\begin{itemize}
\item an initialization function that starts-up the game by setting its inital state
\item a drawing function that (many times per second, at least at around $20Hz$, to give the illusion of smoothness) updates and re-draws the game state
\end{itemize} 
It is common to split the drawing function in two parts:
\begin{itemize}
\item the updating function that updates the game state
\item the drawing function that re-draws the updated game state
\end{itemize}
This further separation is warranted by the complexity of these operations. Updating can be seen as a step of a numerical integrator: we know the state and its derivative with respect to time, and we compute the next state by ``integrating" it. This view is relatively simplistic, but it gives a clear idea of the role of the update function. Also, because of the nature of the update function, its execution must be very fast: if an update lingers for too long, then draw will not be executed and the smootness of the animations will suffer. Long computations must be manually split over various updates.
Drawing is also a complex operation. Usually it involves visibility determinations to avoid rendering parts of the scene that will not be visible on screen, either due to occlusions or because it is outside of the viewing frustum.

The problems we will tackle in this paper are mostly associated with the architecture of a game. We will start by showing how we would build a game in a purely imperative fashion in the C\# language. Our implementation is very straightforward and could have been easily done in C++. This implementation makes use of object orientation in order to build a system of components, so that the transition between the various macro-states of a game (Menu, Play, Victory, Defeat) can be achieved by simply changing the current components of the game. Each component implements its own initialize, update and draw functions. The first implementation does not solve any problems with particular elegance or efficiency; even worse, this implementation cannot be easily parallelized: update and draw cannot be run in parallel because this would introduce grave inconsistencies (like modifying a collection that is being enumerated) or would require locks (which happen to cost \textit{more} than the benefits of parallelization).

We will then modify this implementation so that the gameplay is based on an immutable game state which is re-created at each frame. We will also use LINQ, a technique that origins in functional languages (the list monad), which allows us to write very concise and readable queries that specify how the main collections of our game interact and get updated. Thanks to this implementation we not only achieve a cleaner and more readable source, but we can run the update function in parallel. This yields a very high performance boost: the game runs almost twice as fast. The infrastructure is not completely free though; memory allocation is higher because of the new states that we generate at each update and also because of LINQ, which allocates some internal data-structures to represent lazy queries.

Our final implementation is redone from scratch in F\#. F\# is a multi-paradigm programming language with particular emphasis on the functional side. The ease through which we can define a variable of type function means that we don't need any more components and classes to implement the finite state machine of the game (Menu, Play, Victory, Defeat). Each state of this machine is not a class anymore, but rather it is a triplet of functions: initialize, update and draw. The required architecture is much more lightweight when compared to its object-oriented counterpart. Our F\# implementation makes heavy use of monads to make the policies used when managing the state completely transparent. This way we can use a queue of ``updated" states where the update function puts each new state it generates, and a queue of ``rendered" states that have been drawn on screen by the draw function. This way the update thread becomes the producer of game states and the draw thread (the main thread) becomes the consumer. Also, thanks to monads, we can define our own LINQ-like system for building queries on our data. Moreover, we can define our own flavor of ``stateful queries" where the generation of each element belonging to the result of a query can produce some side-effects. This is very useful for counting the number of destroyed asteroids, for example, for scoring purposes. As a final touch, we show how we can use monads to define ``scripting" code that looks linear but which is automatically split into various executable steps that can then be scheduled inside the update function: this is a very useful touch because it allows us to build software-level threads for running operations which execution would span many invocations of the update function.

Finally, we will discuss the impact that our work has beyond games. From Graphical User Interfaces to multithreading we believe that the approach we have outlined is very powerful since it achieves both clear and concise code but also optimized running time.

The implementation is based on the XNA framework, which offers many facilities that make game development simpler while still retaining a low-level API for fine-tuning complex operations. XNA is also one of relatively few complete game frameworks which cover everything that is needed in games: from the application model to graphics (up to shaders and advanced GPU usage) to audio, input and networking. Also, XNA is based on the .Net framework. This allows us to experiment in a level field with both C\# (an imperative, object-oriented language) and F\# (a multi-paradigm/functional language) with the same very high degree of support; a comparison of C\# and F\# is very ``fair", in that both languages access the same libraries directly and even use the same runtime.

