In this work we presented the architecture of a Metacompiler called Metacasanova, whose meta-language is based on the operational semantics. Metacasanova has been evaluated by re-implementing the DSL for games Casanova, and by implementing a subset of the C language, called C -{}-. Our results show that implementing the language semantics in Metacasanova is up to 8 times shorter than with a hard-coded compiler. The additional abstraction layer of the meta-compiler leads to a performance decay that, in the case of C-{}-, makes the language two times slower than Python, and in the case of Casanova on the same order but still 3 times slower. We identified the problem in the fact that the Meta-language is unaware of the type system and memory model of the implemented language, thus all type checks and memory reads must be done dynamically at runtime. We have proposed a language extension based on \textit{Modules} and \textit{Functors} that allows the meta-language to interface with the type system of the implemented language and to inline the symbol table lookups directly into the generated code. This optimization leads to a performance improvement of 1 order of magnitude, which peaks to 2 order of magnitudes with many updates and data structures with many fields. 

Future work on Metacasanova includes the extension of Casanova with additional abstractions to express networking behaviours in order to ease the implementation of multiplayer games, and the extension of the code generation to support languages for web development to create online applications.