In Section \ref{sec:semantics} we defined the syntax and semantics of Metacasanova. In this section we explain how the abstractions of the language are compiled into the generated code. We chose C\# as target language because the development of Metacasanova started with the idea of expanding the DSL for game development Casanova with further functionalities. Casanova hard-coded compiler generated C\# code as well because it is compatible with game engines such as Unity3D and Monogame. At the same time, C\# grants decent performance without having to manually manage the memory such as for lower-level languages like C/C++. Code generation in different target languages, such as Javascript/Typescript, is possible but still an ongoing project (see Section \ref{sec:conclusion}).

\subsection{Data structures code generation}
The type of each data structure is generated as an interface in C\#. Each data structure defined in Metacasanova is mapped to a \texttt{class} in C\# that implements such interface. The class contains as many fields as the amount of arguments the data structure contains. Each field is given an automatic name \texttt{\tu\tu argC} where \texttt{C} is the index of the argument in the data structure definition. The data structure symbols used in the definition might be pre-processed and replaced in order to avoid illegal characters in the C\# class definition. The class contains an additional field that stores the original name of the data structure before the replacement is performed, used for its ``pretty print''. For example the data structure

\begin{lstlisting}
Data "$i" -> int : Value
\end{lstlisting}

\noindent
will be generated as

\begin{lstlisting}
public interface Value {  }

public class __opDollari : Value
{
  public string __name = "$i";
  public int __arg0;

  public override string ToString()
  {
    return "(" + __name + " " + __arg0 + ")";
  }
}
\end{lstlisting}

\subsection{Code generation for rules}
Each rule contains a set of premises, that in general call different functions to produce a result, and a conclusion that contains the function evaluated by the current rule and the result it produces.

As first step the meta-compiler generates a class for each function defined in the meta-program. This class contains one field for each argument the function accepts. It also contains a field to store the possible result of its evaluation. This field is a \texttt{struct} generated by the meta-compiler defined as follows:

\begin{lstlisting}
public struct __MetaCnvResult<T> { public T Value; public bool HasValue; }
\end{lstlisting}

The result contains a boolean to mark if the rule actually returned a result or failed, and a value which contains the result in case of success.

For example, the function

\begin{lstlisting}
Func eval -> Expr : Value
\end{lstlisting}

\noindent
will be generated as

\begin{lstlisting}
public class eval
{
  public Expr __arg0;
  public __MetaCnvResult<Value> __res;
  ...
}
\end{lstlisting}

The class defines a method \texttt{Run} that performs the actual code execution. The meta-compiler retrieves all the rules which conclusion contains a call to the current function. It then creates a \texttt{switch} structure where each \texttt{case} represents each rule that might execute that function. The result of the rule is also initialized here (the \texttt{struct} will contain a default value and the boolean flag will be set to \texttt{false}). Each \texttt{case} defines a set of local variables, that are the variables used within the scope of that rule.

As first step, the meta-compiler generates the code necessary for the pattern-matching of the conclusion arguments. Since variables always pass the pattern-matching, the code is generated only for arguments explicitly defining a data structure (see the examples about arithmetic operators in Section \ref{sec:semantics}) and literals. If the pattern matching fails then the execution jumps to the next \texttt{case} (rule). For instance, the code for the following conclusion

\begin{lstlisting}
...
-------------
eval (a + b) -> res
\end{lstlisting}

\noindent
is generated as follows

\begin{lstlisting}
case 1:
  ...
  if (!(__arg0 is __opPlus)) { goto case 2; }
\end{lstlisting}

Note that an explicit data type argument, such in the example above, might contain other nested explicit data types arguments, so the pattern-matching is recursively performed on the data structure arguments themselves.
