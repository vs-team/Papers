In this section we show how Casanova 2 can implement the REA pattern, and also extend it with the CDM pattern.

\subsection{Resources}
Resources can be modeled as a Casanova entity with no rules containing a field for each of the resources used in the REA pattern. In a game we might have different resource entities for different group of resources. We define a resource entity by first defining its name \texttt{ResourceName} and then by listing the resources contained in it. A resource in Casanova is a field and it is defined as tuple \texttt{Resource * Type} where the first item refers to the field name while the latter refers to the field type. In the following we show a generalized description for a generic resource entity.

\begin{lstlisting}[mathescape]
entity ResourcesName =
  $\mathtt{R_{1} : T_{1}}$
  $\mathtt{R_{2} : T_{2}}$
  ...
  $\mathtt{R_{n} : T_{n}}$ 
\end{lstlisting}


\subsection{Entities}
REA entities can be modeled directly as Casanova entities. To avoid possible confusion arising from the ambiguity between the \texttt{entity} keyword in Casanova and entities in the REA pattern from now on we will refer to the latter as \textit{actors}. An actor will contain the \texttt{Resources} (of type ResourcesName) and a series of rules that will act as the constant, mutable, and threshold actions of REA.

\begin{lstlisting}
entity Actor = 
  Resources              : ResourcesName
  //constant actions
  //mutable actions
  //threshold actions
\end{lstlisting}

\subsection{Actions}
Following the REA pattern, we divide the actions into 3 categories: (\textit{i}) Constant transfer, (\textit{ii}) mutable transfer, and (\textit{iii}) threshold transfer. We model the REA transfers as rules in Casanova. 


An action in REA simply puts in communication a source with a target. In Casanova the source is the action/rule container while the target is an entity containing a field that refers to the source. Since very often actions are run only after a predicate is satisfied and the predicate might depends on the target properties, among the source fields a field that refers to the target is added. The target checks the source reference whenever it needs to interact with it. 

\noindent
A generalization for this approach could be the following: the source contains \texttt{S} a reference to a target \texttt{T}. Whenever the \texttt{T} needs to interact with an action it traverses the world to find an \texttt{S} that is targeting \texttt{T}. For practicality reasons from now on we use the not generalized version.


\noindent
The action rules do not modify the target actor directly to grant encapsulation, unless the target is the source itself. The source resources are read by the target actor periodically to locally update their fields\footnote{An extensive discussion about encapsulation in games, as well as an optimizer for encapsulated code in Casanova can be found in \cite{CASANOVA2_ENCAPSULATION}}. The resources to transfer generated by actions are stored inside the source entity and precisely inside its resource entity. We refer to the resources to transfer as \texttt{Transfers} in Casanova.

\noindent
The definition of the actions will be shown in the next three paragraphs.

\paragraph*{Constant transfer}
A constant transfer simply sums the resources of a source entity to the resources of the target. The following rule, which is contained in the source entity, updates the \texttt{Transfers} whenever a condition is met (we assume that \texttt{restrictions} is a predicate that specifies a condition to apply the action). The rule waits one frame, to ensure that the target actor reads the change, before resetting the \texttt{Transfers}.

\begin{lstlisting}[mathescape]
enity SourceActor =
  Resources   : ResourcesName
  ref TSource :TargetActor
  ...
  rule Resources.Transfers = 
    wait restrictions
    yield Some(some_resources)
    yield None
\end{lstlisting}


Every time some \texttt{Transfers} are produced the target actor reads them and update its resources accordingly. We use the same \texttt{restriction} as in the source entity to ensure that the generated \texttt{Transfers} belong to that specific target instance. We assume for brevity that we have a + operator for the entity \texttt{Resources}, which behaves like a vector sum, to be used by the aggregate function \texttt{sum} in the query.

\begin{lstlisting}[mathescape]
enity TargetActor =
  Resources   : ResourcesName
  ref ASource : SourceActor
  ...
  rule Resources =
    wait ASource.Transfers.IsSome & restrictions
    yield Resources + ASource.Transfers.Value
   
\end{lstlisting}


\paragraph*{Mutable transfer}
In the mutable transfer the resources are moved from the source to the targets. A transfer can be also negative in REA. In case of negative transfers we simply swap the logic so the source implement the behavior of the target and vice-versa. The rule of the mutable transfer behaves almost the same as for the continuous transfer. Only difference is that in the source together with setting the \texttt{Transfers} by an amount \texttt{some\_resources} we also remove the same \texttt{some\_resources} from the source resources. Again, we assume for brevity that we have a - operator for the entity \texttt{Resources}, which behaves like a vector difference, to be used by the aggregate function \texttt{diff} in the query. 

\begin{lstlisting}[mathescape]
enity SourceActor =
  Resources   : ResourcesName
  ref TSource :TargetActor
  ...
  rule Resources.Transfers, Resources$\mathtt{\setminus\{Transfers\}}$ = 
    wait restrictions
    yield Some(some_resources), Resources$\mathtt{\setminus\{Transfers\}}$ - some_resource
    yield None
\end{lstlisting}

\paragraph*{Threshold transfer}
The threshold transfer is a constant or a mutable transfer that executes the resources transfer, as in the examples above, until a certain \texttt{threshold\_condition} is satisfied. Once we meet the \texttt{threshold\_condition} a series of output values are yielded and then reseted. For this kind of action we need to extend the source entity definition with additional fields to store the output of the rule.

\begin{lstlisting}
enity SourceActor =
  Resources   : ResourcesName
  ref TSource :TargetActor

  Output$\mathtt{_{0}}$ : Option<T$\mathtt{_{0}}$>
  Output$\mathtt{_{1}}$ : Option<T$\mathtt{_{1}}$>
  ...
  Output$\mathtt{_{n}}$ : Option<T$\mathtt{_{n}}$>
  
  Fire : bool
  
  ...
  rule Resources.Transfers, Output$\mathtt{_{0}}$, ..., Output$\mathtt{_{n}}$ = 
    .| threshold_condition ->
      yield None, Some value$\mathtt{_{0}}$, ..., Some value$\mathtt{_{n}}$, Fire
      yield None, None, ..., None, false
      
    .| _ ->    
      wait restrictions
      yield Some(some_resources), Output$\mathtt{_{0}}$, ..., Output$\mathtt{_{n}}$
      yield None, Output$\mathtt{_{0}}$, ..., Output$\mathtt{_{n}}$
\end{lstlisting}

\subsection{Creation}
Creation of an entity follows always an event. In Casanova we can combine the creation expression with any action. This is allowed since inside a rule in Casanova we define the statements to run imperatively. The following shows a generalization for the creation of an object after an action is run. An entity of type \texttt{SomeEntity} is spawned after an action is run.

\begin{lstlisting}
enity SourceActor =
  SomeObject : SomeEnity
  ...
  rule Resources.Transfers, SomeObject =
    // an action
    yield Resources.Transfers, new SomeEnity(some_parameters)
\end{lstlisting}

\subsection{Deletion}
Deletion follows the same code of creation, but we must take into consideration the following: if an instance \texttt{O} is about to get destroyed, all instances \texttt{Is} that share some logic with \texttt{O} must be notified that \texttt{O} is about to get destroyed. An instance of \texttt{Is} knows that \texttt{O} is about to get destroyed when \texttt{O} is moved into a special field called \texttt{DestroyedO}. \texttt{O} is moved into \texttt{DestroyedO} for a certain amount of time and then its reset. In the following code \texttt{SourceActor} contains, besides the usual fields, also a reference to an object \texttt{O} of type \texttt{Object} and to \texttt{DestroyedO}.

\begin{lstlisting}
enity SourceActor =
  ref DestroyedO : Option<Object>
  O : Option<Object>
  ...
  rule O, DestroyedO =    
    wait restrictions
    let acc = O
    yield None, Some acc
\end{lstlisting}


\subsection{Change of strategy}
An entity moves according to some logic. In this case we can apply a constant transfer to for example update an entity position according to its velocity. An entity might change its behavior according to some conditions. For example a fleet might change from traveling to attacking. This kind of behavior might resemble the strategy pattern and in Casanova we implement it by explicitly moving the moving object from a container of type \texttt{F} into an other container of type \texttt{T}. \texttt{T} and \texttt{F} share few information like physical information, graphics, etc. but differ in terms of behavior. We can generalize the movement behavior by combining the above actions. We start first with the definition of an entity \texttt{MovingActor} which is an entity that moves the position of its instance according to its velocity.

\begin{lstlisting}
enity MovingActor =
	Resources : ResourcesName
	
	rule Resources.Position = yield Resources.Position + Resources.Velocity * dt
	//.. other rules and fields
\end{lstlisting}

An entity \texttt{ActionActor} is an entity that shares some structure with the \texttt{MovingActor} entity (for example the position or the velocity) but implements different rules.

\begin{lstlisting}
enity ActionActor =
  Resources : ResourcesName
  
  rule Resources.Position = // move around a target for example
  rule Resources.Life = // remove life if the entity is hit
  //.. other rules and fields
\end{lstlisting}

A \texttt{SourceActor} is an entity that contains among its fields a \texttt{MovingActor} and an \texttt{ActionActor} field. \texttt{SourceActor} combines the actions described above so that when an entity of type \texttt{MovingActor} needs to behave like an \texttt{ActionActor} we use the deletion pattern to move the \texttt{MovingActor} into a temporary location, so to give time notify all the entities, and then we assign it to \texttt{ActionActor}. The code below shows the just presented solution.

\begin{lstlisting}
enity SourceActor =
  AActor : Option<ActionActor>
  ref AActorToDestroy : Option<ActionActor>
  MActor : Option<MovingActor>
  
  rule AActor, AActorToDestroy = // same logic as deletion
  
  rule MActor = 
    wait AActorToDestroy.IsSome
    yiel new MActor(AActorToDestroy.Value.Resources) |> Some
\end{lstlisting}