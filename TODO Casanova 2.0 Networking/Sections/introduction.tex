Adding multi-player support to games is a highly desirable feature. By letting players interact with each other, new forms of gameplay, cooperation, and competition emerge without requiring any additional design of game mechanics. This allows a game to remain fresh and playable, even after the single player content has been exhausted. For example, consider any modern AAA game such as \textit{Halo 4}. After months since its initial release, most players have exhausted the single player, narrative-driven campaign. Nevertheless the game remains heavily in use thanks to multiplayer modes, which in effect extended the life of the game significantly. This phenomenon is even more evident with games such as \textit{World of Warcraft} or \textit{EVE}, where multiplayer is the only modality of play and there is no single-player experience. Nowadays essentially all AAA games feature some form of multiplayer. On the other hand, unfortunately, smaller games such as casual games, serious games, mobile games, etc. very often lack multiplayer. We believe this phenomenon to be caused by technical issues.

\paragraph{Challenges}
Multi-player support in games is a very expensive piece of software to build. Multiplayer games are under strong pressure to have very good \textit{performance}. Performance is both in terms of CPU time, and in bandwidth used. Also, games need to be very \textit{robust} with respect to transmission delays, packets lost, or even clients disconnected. To make matters worse, players often behave erratically. It is widespread practice among players to leave a competitive game as soon as their defeat is apparent (a phenomenon so common to even have its own name: ``rage quitting''), or to try to abuse the game and its technical flaws to gain advantages or to disrupt the experience of others.

Networking code reuse is quite low across titles and projects. This comes from the fact that the requirements of every game vary significantly: from turn-based games that only need to synchronize the game world every few seconds, and where latency is not a big issue, to first-person-shooter games where prediction mechanisms are needed to ensure the smooth movement of synchronized entities, to real-time-strategy games where thousands of units on the screen all need to be synchronized across game instances. In short, previous effort is substantially inaccessible for new titles.

\paragraph{Existing approaches}
Networking in games is usually built with either very low level or very high level mechanisms. Very low level mechanisms are based on manually sending streams of bytes and serializing only the essential bits of the game world, usually incrementally, on unreliable channels (UDP). This coding process is highly expensive. Such a low level protocol is difficult to get right, and debugging subtle protocol mismatches, transmission errors, etc. will take lots of development resources. Low-level mechanisms must also be very robust, making the task even harder.

High level protocols such as RDP, reflection-based serialization, etc. can also be used. These methods greatly simplify  networking code, but are rarely used in complex games and scenarios. The requirements of performance mean that many high-level protocols or mechanisms are insufficient, either because they are too slow computationally (especially when the rely on reflection) or because they transmit too much data across the network.

\paragraph{Our approach}
To avoid the problems of both existing approaches, we propose a middle ground. We observe that networking models and algorithms do not vary substantially between games, even though the code that needs to be written to implement them does. The similarity comes from the fact that the ways to serialize, synchronize, and predict the behaviour of entities are relatively standard and described according to a limited series of general ideas. The difference, on the other hand, comes from the fact that low-level protocols need to be adapted to the specific structure of the game world and the data structures that make it up. Until now, common primitives have not been syntactically and semantically captured inside existing languages. Using the right level of abstraction, these general patterns of networking can be captured, while leaving full customization power in the hand of the developer (to apply such primitives to any kind of game).

Networking code can thus be seen as a series of (parametric) transformations from the data definitions of the game world and its structures, into the code that serializes these structures within the constraints imposed by games. This leads us to believe that the difficulties in networking do not stem from an intrinsic, theoretical or fundamental difficulty, but rather they come from the lack of ability of modern programming languages to capture such complex (inductive) transformations from data structures into algorithms. By designing the proper abstractions for networking at the language level, we aim at simplifying the task of building low-level networking protocols for games. We wish to, at the same time, give the developer more powerful and flexible tools to build networking code, always at the proper level of abstraction. We wish to avoid something that is really low-level, for example just a few byte-sending primitives, because this would not really solve the problem but would instead just offer some ready-made functions to call. At the same time we want to avoid extremely high-level primitives such as \texttt{synchronize-world}, because these would take away the flexibility to design ad-hoc protocols for each scenario. 

Finally, we observe that a good system for building multiplayer in games should support timed-protocols and in general a complex flow of control that explicitly mentions time. For example, concurrent waiting operators should be a first class element, in order to be able to express a concept such as \textit{perform an operation after you receive a specific message}.

\paragraph{Contribution of this work.} \textbf{In this paper we present a programming language with explicit support for networking in games. Our technique is a middle ground between high level and low level networking solutions, and it allows building networking protocols with the desired level of granularity and performance.}

\paragraph{Our approach.} We begin by discussing networking in games and the technical challenges it presents (Section \ref{sec:problem}). We then provide the general intuition of our system and its primitives, and we show how to build some example games in it (Section \ref{sec:idea}). We then formalize the system by providing the language syntax and semantics (Section \ref{sec:definition}). Finally, we provide an evaluation of the language based on a user study and a series of performance and bandwidth benchmarks (Section \ref{sec:evaluation}).
