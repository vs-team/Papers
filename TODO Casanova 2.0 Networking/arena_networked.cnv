// Warning: this is the best example for the compiler translations.
// DO NOT USE THE OTHER SAMPLES, as they are semantically weaker.
// NOTE: yield operations generated by the compiler should take
// zero frames, that is they are just assignments that fall
// through directly.


// compiler-generated
entity InMessageBool = ...
entity ReliableOutMessageBool = ...
...
entity Mailbox = {
  InboxBool           : List<InMessageBool>
  InboxInt            : List<InMessageInt>
  ...
  Outbox              : List<OutMessage>
  OutboxReliable      : List<OutMessage>
  Id                  : EntityId

  rule Outbox = yield []
  rule OutboxReliable = yield []
  rule InboxBool = 
    yield InboxBool +
          from c in Network.Peers
          from m in c.ReceivedMessages
          where m.ContentType = BoolTypeId &&
                m.OwnerEntity = Id
          select InMessageBool.Create(m.Value)
  rule InboxInt = 
    yield InboxInt +
          from c in Network.Peers
          from m in c.ReceivedMessages
          where m.ContentType = IntTypeId &&
                m.OwnerEntity = Id
          select InMessageInt.Create(m.Value)
  ...
  Create(id) = { ... }
}



world Arena = {
  Self		: Ship
  Others	: List<Ship>
  Network : NetManager
  Id      : EntityId
  Mailbox : Mailbox

  rule Others,Mailbox.Outbox,Mailbox.InboxPlayers,Network.MasterConnect = 
    wait_until (Network.MasterConnect = true)
    let msg = ReliableOutMessageShip.Create(Self, [], Network.Id, Id).ReliableOutMessage
    yield Mailbox.Outbox <- Mailbox.Outbox + msg
    wait_until(msg.Received)
    wait_until(from m in Mailbox.InboxPlayers
               select m
               group_by m.Sender
               count = Network.Peers.Length)
    let others = // take one item per peer
      from m in Mailbox.InboxPlayers
      select m
      group_by m.Sender as g
      select g.Elements.Head.Value
    yield Mailbox.InboxPlayers <- []
    yield Others <- others, Network.MasterConnect <- false

  rule Others,Mailbox.Outbox,Mailbox.InboxPlayers,Network.SlaveConnect = 
    wait_until (Network.SlaveConnect = true)
    wait_until(Mailbox.InboxPlayers.Length > 1)
    let new_other = Mailbox.InboxPlayers.Head.Value
    yield Mailbox.InboxPlayers <- Mailbox.InboxPlayers.Tail
    let msg = ReliableOutMessageShip.Create(Self, [], Network.Id, Id).ReliableOutMessage
    yield Mailbox.Outbox <- Mailbox.Outbox + msg
    wait_until(msg.Received)
    yield Others <- Others + new_other, Network.SlaveConnect <- false

  Create(self:LobbyPlayer) =
    let network = NetManager.Create()
    let id = network.NextId
    {
      Self    = Ship.Create(self.StartPosition)
      Others  = []
      Network = network
      Id      = id
      Mailbox = Mailbox.Create(id)
    }
}


entity Ship = {
  Position    : Vector2<pixel>
  Velocity    : Vector2<pixel/s>
  Health      : float<health>
  Shots       : List<Projectile>
  Hits        : List<Ref<Ship>>
  Mailbox     : Mailbox
  Id          : int
  Ownership   : NetOwnership

  rule Position,Mailbox.Outbox = 
    wait_until (Ownership = Master)
    while(true)
      let res = Position + Velocity * dt
      let msg = OutMessageVector2Pixel.Create(res, [], world.Network.Id, Id).OutMessage
      yield res, Mailbox.Outbox + msg
  rule Velocity,Mailbox.Outbox = 
    wait_until (Ownership = Master)
    while(true)
      ... input-specific code
      let res = ...
      let msg = OutMessageVector2PixelPerS.Create(res, [], world.Network.Id, Id).OutMessage
      yield res, Mailbox.Outbox + msg
  rule Health,Mailbox.Outbox = 
    wait_until (Ownership = Master)
    while(true)
      let res = Health - from o in world.Others
                         from h in o.Hits
                         where h = Self
                         select 1
                         sum)
      let msg = OutMessageFloatHealth.Create(res, [], world.Network.Id, Id).OutMessage
      yield res, Mailbox.Outbox + msg        
  rule Shots,Mailbox.Outbox = 
    wait_until (Ownership = Master)
    while(true)
      ... input-specific code
      let new_shot = ...
      let msg = OutMessageProjectile.Create(new_shot, [], world.Network.Id, Id).OutMessage
      yield Shots + new_shot, Mailbox.Outbox + msg
  rule Hits,Shots,Mailbox.ReliableOutbox = 
    wait_until (Ownership = Master)
    while(true)
      ... partition Shots into shots and hits
      let hits',shots' = ... 
      send_reliable<List<Hits>>(hits')
      let msg = OutMessageProjectile.Create(new_shot, [], world.Network.Id, Id).OutMessage
      yield Mailbox.ReliableOutbox <- Mailbox.ReliableOutbox + msg
      wait_until(msg.Received)
      yield Hits <- hits', Shots <- shots'

  rule Position,Mailbox.InboxVector2Pixel = 
    wait_until (Ownership <> Master)
    while(true)
      wait_until(Mailbox.InboxVector2Pixel.Length > 1)
      yield Mailbox.InboxVector2Pixel.Head.Value,Mailbox.InboxVector2Pixel.Tail
  rule Velocity,Mailbox.InboxVector2PixelPerS =
    wait_until (Ownership <> Master)
    while(true)
      wait_until(Mailbox.InboxVector2PixelPerS.Length > 1)
      yield Mailbox.InboxVector2PixelPerS.Head.Value,Mailbox.InboxVector2PixelPerS.Tail
  rule Health,Mailbox.InboxFloatHealth =
    wait_until (Ownership <> Master)
    while(true)
      wait_until(Mailbox.InboxFloatHealth.Length > 1)
      yield Mailbox.InboxFloatHealth.Head.Value,Mailbox.InboxFloatHealth.Tail
  rule Shots,Mailbox.InboxProjectile =
    wait_until (Ownership <> Master)
    while(true)
      wait_until(Mailbox.InboxProjectile.Length > 1)
      yield Shots + Mailbox.InboxProjectile.Head.Value,Mailbox.InboxProjectile.Tail
  rule Hits,Mailbox.InboxListHit = 
    wait_until (Ownership <> Master)
    while(true)
      wait_until(Mailbox.InboxListHit.Length > 1)
      yield Mailbox.InboxListHit.Head.Value,Mailbox.InboxListHit.Tail
      yield Hits <- []

  rule Shots = 
    from s in Shots
    where s.Active
    select s

  Create(p,network:NetManager) =
    let id = network.NextId
    {
      Position    = p
      Velocity    = Vector2.Zero
      Health      = 100.0<health>
      Shots       = []
      Hits        = []
      Mailbox     = Mailbox.Create(id)
      Id          = id
      Ownership   = Master
    }
}


entity Projectile = {
  Position    : Vector2<pixel>
  Velocity    : Vector2<pixel/s>
  Active      : bool
  Id          : EntityId
  Ownership   : NetOwnership
  Mailbox     : Mailbox

  rule Position = Position + Velocity * dt

  rule Position,Mailbox.Outbox = 
    wait_until (Ownership = Master)
    while(true)
      wait(5.0f<s>)
      let res = Position
      let msg = OutMessageVector2Pixel.Create(res, [], world.Network.Id, Id).OutMessage
      yield res, Mailbox.Outbox + msg
  rule Velocity,Mailbox.Outbox = 
    wait_until (Ownership = Master)
    while(true)
      wait(10.0f<s>)
      let res = Velocity
      let msg = OutMessageVector2PixelPerS.Create(res, [], world.Network.Id, Id).OutMessage
      yield res, Mailbox.Outbox + msg
  rule Active,Mailbox.Outbox = 
    wait_until (Ownership = Master)
    while(true)
      wait(20.0f<s>)
      let res = false
      let msg = OutMessageBool.Create(res, [], world.Network.Id, Id).OutMessage
      yield res, Mailbox.Outbox + msg

  rule Position,Mailbox.InboxVector2Pixel = 
    wait_until (Ownership <> Master)
    while(true)
      wait_until(Mailbox.InboxVector2Pixel.Length > 1)
      yield Mailbox.InboxVector2Pixel.Head.Value,Mailbox.InboxVector2Pixel.Tail
  rule Velocity,Mailbox.InboxVector2PixelPerS =
    wait_until (Ownership <> Master)
    while(true)
      wait_until(Mailbox.InboxVector2PixelPerS.Length > 1)
      yield Mailbox.InboxVector2PixelPerS.Head.Value,Mailbox.InboxVector2PixelPerS.Tail
  rule Active,Mailbox.InboxBool =
    wait_until (Ownership <> Master)
    while(true)
      wait_until(Mailbox.InboxBool.Length > 1)
      yield Mailbox.InboxBool.Head.Value,Mailbox.InboxBool.Tail

  Create(p,v,network:NetManager) =
    let id = network.NextId
    {
      Position    = p
      Velocity    = v
      Active      = true
      Mailbox     = Mailbox.Create(id)
      Id          = id
      Ownership   = Master
    }
}
